uniform sampler2D texUnit;
uniform float fWidth;
uniform float fHeight;
uniform sampler2D texUnitSrc;
uniform float fWidthSrc;
uniform float fHeightSrc;
uniform int effectenable;
uniform int grayscale;
uniform int sharpenMasking;
uniform int tone;
uniform int colorboost;
uniform int denoise;
uniform int filmgrain;
uniform float sharpness;
uniform float contrast;
uniform float brightness;
uniform float red;
uniform float green;
uniform float blue;

uniform float sigma;
uniform float threshold;
uniform float kSigma;

uniform int left;
uniform int top;
uniform int bitmapWidth;
uniform int bitmapHeight;
uniform int flipH;
uniform int flipV;
uniform int angle;
uniform int type;
uniform float ratio;

uniform float timer;
const float permTexUnit = 1.0/256.0;		// Perm texture texel-size
const float permTexUnitHalf = 0.5/256.0;	// Half perm texture texel-size
const float grainamount = 0.03; //grain amount

//a random texture generator, but you can also use a pre-computed perturbation texture
vec4 rnm(in vec2 tc) 
{
    float noise =  sin(dot(tc + vec2(timer,timer),vec2(12.9898,78.233))) * 43758.5453;

	float noiseR =  fract(noise)*2.0-1.0;
	float noiseG =  fract(noise*1.2154)*2.0-1.0; 
	float noiseB =  fract(noise*1.3453)*2.0-1.0;
	float noiseA =  fract(noise*1.3647)*2.0-1.0;
	
	return vec4(noiseR,noiseG,noiseB,noiseA);
}

float fade(in float t) {
	return t*t*t*(t*(t*6.0-15.0)+10.0);
}

float pnoise3D(in vec3 p)
{
	vec3 pi = permTexUnit*floor(p)+permTexUnitHalf; // Integer part, scaled so +1 moves permTexUnit texel
	// and offset 1/2 texel to sample texel centers
	vec3 pf = fract(p);     // Fractional part for interpolation

	// Noise contributions from (x=0, y=0), z=0 and z=1
	float perm00 = rnm(pi.xy).a ;
	vec3  grad000 = rnm(vec2(perm00, pi.z)).rgb * 4.0 - 1.0;
	float n000 = dot(grad000, pf);
	vec3  grad001 = rnm(vec2(perm00, pi.z + permTexUnit)).rgb * 4.0 - 1.0;
	float n001 = dot(grad001, pf - vec3(0.0, 0.0, 1.0));

	// Noise contributions from (x=0, y=1), z=0 and z=1
	float perm01 = rnm(pi.xy + vec2(0.0, permTexUnit)).a ;
	vec3  grad010 = rnm(vec2(perm01, pi.z)).rgb * 4.0 - 1.0;
	float n010 = dot(grad010, pf - vec3(0.0, 1.0, 0.0));
	vec3  grad011 = rnm(vec2(perm01, pi.z + permTexUnit)).rgb * 4.0 - 1.0;
	float n011 = dot(grad011, pf - vec3(0.0, 1.0, 1.0));

	// Noise contributions from (x=1, y=0), z=0 and z=1
	float perm10 = rnm(pi.xy + vec2(permTexUnit, 0.0)).a ;
	vec3  grad100 = rnm(vec2(perm10, pi.z)).rgb * 4.0 - 1.0;
	float n100 = dot(grad100, pf - vec3(1.0, 0.0, 0.0));
	vec3  grad101 = rnm(vec2(perm10, pi.z + permTexUnit)).rgb * 4.0 - 1.0;
	float n101 = dot(grad101, pf - vec3(1.0, 0.0, 1.0));

	// Noise contributions from (x=1, y=1), z=0 and z=1
	float perm11 = rnm(pi.xy + vec2(permTexUnit, permTexUnit)).a ;
	vec3  grad110 = rnm(vec2(perm11, pi.z)).rgb * 4.0 - 1.0;
	float n110 = dot(grad110, pf - vec3(1.0, 1.0, 0.0));
	vec3  grad111 = rnm(vec2(perm11, pi.z + permTexUnit)).rgb * 4.0 - 1.0;
	float n111 = dot(grad111, pf - vec3(1.0, 1.0, 1.0));

	// Blend contributions along x
	vec4 n_x = mix(vec4(n000, n001, n010, n011), vec4(n100, n101, n110, n111), fade(pf.x));

	// Blend contributions along y
	vec2 n_xy = mix(n_x.xy, n_x.zw, fade(pf.y));

	// Blend contributions along z
	float n_xyz = mix(n_xy.x, n_xy.y, fade(pf.z));

	// We're done, return the final noise value.
	return n_xyz;
}


#define INV_SQRT_OF_2PI 0.39894228040143267793994605993439  // 1.0/SQRT_OF_2PI
#define INV_PI 0.31830988618379067153776752674503
//  smartDeNoise - parameters
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//  sampler2D tex     - sampler image / texture
//  vec2 uv           - actual fragment coord
//  float sigma  >  0 - sigma Standard Deviation
//  float kSigma >= 0 - sigma coefficient 
//      kSigma * sigma  -->  radius of the circular kernel
//  float threshold   - edge sharpening threshold 


//------------------------------------------------------------
//------------------------------------------------------------
//Interpolation Code												   
//------------------------------------------------------------
//------------------------------------------------------------
#define FILTER_PI 3.1415926535
#define FILTER_2PI 2.0 * 3.1415926535
#define FILTER_4PI 4.0 * 3.1415926535

// Inline device function to convert 32-bit unsigned integer to floating point rgba color 
//*****************************************************************
float KernelFilter_selection(float f)
{
	float x = f;

/*
	if(type == 1)
	{
		float width = 0.5;
		return (f <= width ? 1.0 : 0.0);
	}
	if(type == 2)
	{
		float m_dWidth = 1.5;
		if (x > m_dWidth) 
			return 0.0; 

		if (x < -1.0)
			return(0.0);
		if (x < 0.0)
			return((2.0*(-x)-3.0)*(-x)*(-x)+1.0);
		if (x < 1.0)
			return((2.0*x-3.0)*x*x+1.0);
		return(0.0);
	}
	if(type == 3)
	{
		if (x > 1.0) 
		{
			return 0.0; 
		}

		return(0.54+0.46*cos(FILTER_PI*x));
	}	
	if(type == 4)
	{
		float m_dWidth = 2.0;
		if (x > m_dWidth) 
		{
			return 0.0; 
		}

		if (x < -2.0)
			return(0.0);
		if (x < -1.0)
			return(0.5*(4.0+x*(8.0+x*(5.0+x))));
		if (x < 0.0)
			return(0.5*(2.0+x*x*(-5.0-3.0*x)));
		if (x < 1.0)
			return(0.5*(2.0+x*x*(-5.0+3.0*x)));
		if (x < 2.0)
			return(0.5*(4.0+x*(-8.0+x*(5.0-x))));
		return(0.0);
	}		
	if(type == 5)
	{
		if (x > 2.0) 
			return 0.0; 

		#define B   (1.0/3.0)
		#define C   (1.0/3.0)
		#define P0  ((  6.0- 2.0*B       )/6.0)
		#define P2  ((-18.0+12.0*B+ 6.0*C)/6.0)
		#define P3  (( 12.0- 9.0*B- 6.0*C)/6.0)
		#define Q0  ((       8.0*B+24.0*C)/6.0)
		#define Q1  ((     -12.0*B-48.0*C)/6.0)
		#define Q2  ((       6.0*B+30.0*C)/6.0)
		#define Q3  ((     - 1.0*B- 6.0*C)/6.0)

		if (x < -2.0)
			return(0.0);
		if (x < -1.0)
			return(Q0-x*(Q1-x*(Q2-x*Q3)));
		if (x < 0.0)
			return(P0+x*x*(P2-x*P3));
		if (x < 1.0)
			return(P0+x*x*(P2+x*P3));
		if (x < 2.0)
			return(Q0+x*(Q1+x*(Q2+x*Q3)));
		return(0.0);
	}	
	if(type == 6)
	{
		if (x > 1.0) 
			return 0.0; 
		if (x < -1.0)
			return(0.0);
		if (x < 0.0)
			return(1.0+x);
		if (x < 1.0)
			return(1.0-x);
		return(0.0);
	}	
	if(type == 7)
	{
		if (x > 1.5) 
		{
			return 0.0; 
		}

		if (x < -1.5)
			return(0.0);
		if (x < -0.5)
			return(0.5*(x+1.5)*(x+1.5));
		if (x < 0.5)
			return(0.75-x*x);
		if (x < 1.5)
			return(0.5*(x-1.5)*(x-1.5));
		return(0.0);
	}	
	if(type == 8)
	{
		if (x > 1.0) 
		{
			return 0.0; 
		}
		float dN = 2.0 * 1.0 + 1.0; 
		return 0.42 + 0.5 * cos(FILTER_2PI * x / ( dN - 1.0 )) + 0.08 * cos (FILTER_4PI * x / ( dN - 1.0 )); 
	}	
	if(type == 9)
	{
		if (x > 1.0) 
		{
			return 0.0; 
		}
		float dWindow = 0.54 + 0.46 * cos (FILTER_2PI * x); 
		float dSinc = (x == 0) ? 1.0 : sin (FILTER_PI * x) / (FILTER_PI * x); 
		return dWindow * dSinc;
	}	
	if(type == 10)
	{
		if (x > 1.25) 
		{
			return 0.0;
		}
		return exp(-x * x / 2.0) / sqrt (FILTER_2PI); 
	}
	if(type == 11)
	{
		return (x < 1.0 ? 1.0 - x : 0.0); 
	}	
*/
	if (x > 2.0) 
	{
		return 0.0; 
	}

	if (x < -2.0)
		return(0.0);
	if (x < -1.0)
		return((2.0+x)*(2.0+x)*(2.0+x)/6.0);
	if (x < 0.0)
		return((4.0+x*x*(-6.0-3.0*x))/6.0);
	if (x < 1.0)
		return((4.0+x*x*(-6.0+3.0*x))/6.0);
	if (x < 2.0)
		return((2.0-x)*(2.0-x)*(2.0-x)/6.0);
	return(0.0);
}

//------------------------------------------------------------
//TextureValue													   
//------------------------------------------------------------
vec4 GetColorSrc(float posX, float posY, float xDiff, float yDiff)
{
	float texelSizeX = 1.0 / fWidthSrc; //size of one texel 
	float texelSizeY = 1.0 / fHeightSrc; //size of one texel 
	vec2 resolution = vec2(texelSizeX, texelSizeY); 
	return texture2D(texUnitSrc, vec2(posX,posY) + resolution * vec2(xDiff, yDiff));
}

//------------------------------------------------------------
//TextureValue													   
//------------------------------------------------------------
vec4 KernelExecution(float x, float y)
{
	vec4 nDenom = vec4(0.0);
	float valueA = x;
	float valueB = y;
	float realA = x - valueA;
	float realB = y - valueB;
	
	vec4 fy1 = vec4(KernelFilter_selection(-(-1.0 - realB)));
	vec4 fy2 = vec4(KernelFilter_selection(realB));
	vec4 fy3 = vec4(KernelFilter_selection(-(1.0 - realB)));
	
	vec4 fx1 = vec4(KernelFilter_selection(-1.0 - realA));
	vec4 fx2 = vec4(KernelFilter_selection(- realA));
	vec4 fx3 = vec4(KernelFilter_selection(1.0 - realA));
	
	nDenom += fy1 * (fx1 + fx2 + fx3) + fy2 * (fx1 + fx2 + fx3) + fy3 * (fx1 + fx2 + fx3);

	
	vec4 sum = GetColorSrc(x, y, -1.0, -1.0) * (fy1 * fx1);
	sum += GetColorSrc(x, y, 0.0, -1.0) * (fy1 * fx2);
	sum += GetColorSrc(x, y, 1.0, -1.0) * (fy1 * fx3);
	
	sum += GetColorSrc(x, y, -1.0, 0.0) * (fy2 * fx1);
	sum += GetColorSrc(x, y, 0.0, 0.0) * (fy2 * fx2);
	sum += GetColorSrc(x, y, 1.0, 0.0) * (fy2 * fx3);

	sum += GetColorSrc(x, y, -1.0, 1.0) * (fy3 * fx1);
	sum += GetColorSrc(x, y, 0.0, 1.0) * (fy3 * fx2);
	sum += GetColorSrc(x, y, 1.0, 1.0) * (fy3 * fx3);
	
    return sum / nDenom;
}

//------------------------------------------------------------
//TextureValue													   
//------------------------------------------------------------
vec4 CalculInterpolation(float ratioX, float ratioY, vec2 positionTexture)
{

	float texelSizeX = 1.0 / fWidthSrc; //size of one texel 
	float texelSizeY = 1.0 / fHeightSrc; //size of one texel 
	vec2 resolution = vec2(texelSizeX, texelSizeY); 
	vec2 posResolution = resolution * vec2(left, top);

	float posX = positionTexture.x * ratioX + posResolution.x * ratioX;
	float posY = positionTexture.y * ratioY + posResolution.y * ratioY;

	if (angle == 270)
	{
		float srcx = posY;
		float srcy = posX;

		posX = srcx;
		posY = srcy;

		posX = 1.0 - posX;
	}
	else if (angle == 180)
	{
		posX = 1.0 - posX;
		posY = 1.0 - posY;
	}
	else if (angle == 90)
	{
		float srcx = posY;
		float srcy = posX;

		posX = srcx;
		posY = srcy;

		posY = 1.0 - posY;
	}
	
	if(angle == 90 || angle == 270)
	{
		if (flipV == 1)
		{
			posX = 1.0 - posX;
		}

		if (flipH == 1)
		{
			posY = 1.0 - posY;
		}
	
	}
	else
	{
		if (flipH == 1)
		{
			posX = 1.0 - posX;
		}

		if (flipV == 1)
		{
			posY = 1.0 - posY;
		}
	}

	
	//if(type == 12)
	//	return GetColorSrc(posX, posY, 0.0, 0.0);
	//return KernelExecution(posX, posY);
	return GetColorSrc(posX, posY, 0.0, 0.0);
}

//------------------------------------------------------------
//TextureValue													   
//------------------------------------------------------------

vec4 TextureValue(float posX, float posY, float xDiff, float yDiff)
{
	vec4 color;
	float texelSizeX = 1.0 / fWidth; //size of one texel 
	float texelSizeY = 1.0 / fHeight; //size of one texel 
	vec2 positionTexture = vec2(posX,posY) + vec2(texelSizeX, texelSizeY) * vec2(xDiff, yDiff); 
	
	float srcTexelSizeX = 1.0 / fWidthSrc; //size of one texel 
	float srcTexelSizeY = 1.0 / fHeightSrc; //size of one texel 
	
	float diffx = srcTexelSizeX / texelSizeX;
	float diffy = srcTexelSizeY / texelSizeY;
	
	positionTexture.x = (positionTexture.x / texelSizeX) * srcTexelSizeX;
	positionTexture.y = (positionTexture.y / texelSizeY) * srcTexelSizeY;
	
	if(ratio == 1.0)
	{
		float ratioX = fWidthSrc / fWidth;
		float ratioY = fHeightSrc / fHeight;
		color = CalculInterpolation(ratioX, ratioY, positionTexture);
	}
	else
	{
		float ratioX = fWidthSrc / bitmapWidth;
		float ratioY = fHeightSrc / bitmapHeight;
		color = CalculInterpolation(ratioX, ratioY, positionTexture);
	}
	return color;
}

//------------------------------------------------------------
//ContrastFilter													   
//------------------------------------------------------------
vec4 ContrastFilter(vec4 color,float contrast, float offset)
{
	float csupp = contrast * (offset - 256.0) + 128.0;
	
	float red = contrast * (color.r * 255.0) + csupp;
	if (red < 0.0)
		red = 0.0;
	else if (red > 255.0)
		red = 255.0;	
		
	float blue = contrast * (color.b * 255.0) + csupp;
	if (blue < 0.0)
		blue = 0.0;
	else if (blue > 255.0)
		blue = 255.0;	

	float green = contrast * (color.g * 255.0) + csupp;
	if (green < 0.0)
		green = 0.0;
	else if (green > 255.0)
		green = 255.0;

	return vec4(red / 255.0, green / 255.0, blue / 255.0, color.a);		

}

//------------------------------------------------------------
//LightnessFilter													   
//------------------------------------------------------------
vec4 LightnessFilter(vec4 color)
{
	float nChange = (2.55 * brightness) / 255.0;
	return vec4(color.r + nChange, color.g + nChange, color.b + nChange, color.a);
}

//------------------------------------------------------------
//ApplyFilter													   
//------------------------------------------------------------
vec4 ApplyFilter(vec4 src_color)
{	
	if(sharpenMasking == 1)
	{
		vec4 sum;
		float posX = gl_TexCoord[0].s;
		float posY = gl_TexCoord[0].t;
		sum =  TextureValue(posX, posY, -1.0, -1.0);
		sum += TextureValue(posX, posY, 0.0, -1.0);
		sum += TextureValue(posX, posY, 1.0, -1.0);
		sum += TextureValue(posX, posY, -1.0, 0.0);
		sum += src_color;
		sum += TextureValue(posX, posY, 1.0, 0.0);
		sum += TextureValue(posX, posY, -1.0, 1.0);
		sum += TextureValue(posX, posY, 0.0, 1.0);
		sum += TextureValue(posX, posY, 1.0, 1.0);
		vec4 blur = sum / vec4(9.0,9.0,9.0,9.0);
		src_color = src_color + (src_color - blur) * sharpness;		
	}

	if(tone == 1)
	{
		if (contrast == 0.0)
		{
			src_color = ContrastFilter(src_color, 1.0, 128.0);
		}
		else if (contrast > 0.0)
		{
			float offset = contrast;
			offset /= 100.0;
			offset = 1.0 + offset;
			src_color = ContrastFilter(src_color, offset, 128.0);
		}
		else if (contrast < 0.0)
		{
			float offset = -contrast;
			offset /= 100.0;
			offset = 1.0 - offset;
			src_color = ContrastFilter(src_color, offset, 128.0);
		}
	
		src_color = LightnessFilter(src_color);
	}

	if(colorboost == 1)
	{
		float _localred = red / 255.0; 
		float _localgreen = green / 255.0; 
		float _localblue = blue / 255.0; 

		_localred = src_color.r + _localred;
		_localgreen = src_color.g + _localgreen;
		_localblue = src_color.b + _localblue;

		if (_localred > 1.0)
			_localred = 1.0;

		if(_localred < 0.0)
			_localred = 0.0;

		if (_localgreen > 1.0)
			_localgreen = 1.0;

		if(_localgreen < 0.0)
			_localgreen = 0.0;

		if (_localblue > 1.0)
			_localblue = 1.0;

		if(_localblue < 0.0)
			_localblue = 0.0;

		src_color = vec4(_localred, _localgreen, _localblue, src_color.a);
	}

	if(grayscale == 1)
	{
		float sum = src_color.r * 0.299 + src_color.b * 0.114 + src_color.g * 0.587;
		src_color = vec4(sum, sum, sum, src_color.a);
	}
	
	return src_color;
}

//------------------------------------------------------------
//Denoise													   
//------------------------------------------------------------
vec4 Denoise(vec4 centrPx)
{
    float radius = round(kSigma*sigma);
    float radQ = radius * radius;

    float invSigmaQx2 = .5 / (sigma * sigma);      // 1.0 / (sigma^2 * 2.0)
    float invSigmaQx2PI = INV_PI * invSigmaQx2;    // // 1/(2 * PI * sigma^2)

    float invThresholdSqx2 = .5 / (threshold * threshold);     // 1.0 / (sigma^2 * 2.0)
    float invThresholdSqrt2PI = INV_SQRT_OF_2PI / threshold;   // 1.0 / (sqrt(2*PI) * sigma)

    float zBuff = 0.0;
    vec4 aBuff = vec4(0.0);
	
	float posX = gl_TexCoord[0].s;
	float posY = gl_TexCoord[0].t;	

    vec2 d;
    for (d.x=-radius; d.x <= radius; d.x++) {
        float pt = sqrt(radQ-d.x*d.x);       // pt = yRadius: have circular trend
        for (d.y=-pt; d.y <= pt; d.y++) {
            float blurFactor = exp( -dot(d , d) * invSigmaQx2 ) * invSigmaQx2PI;

			vec4 walkPx = ApplyFilter(TextureValue(posX, posY, d.x, d.y));
            vec4 dC = walkPx-centrPx;
            float deltaFactor = exp( -dot(dC, dC) * invThresholdSqx2) * invThresholdSqrt2PI * blurFactor;

            zBuff += deltaFactor;
            aBuff += deltaFactor*walkPx;
        }
    }
    return aBuff/zBuff;
}
//------------------------------------------------------------
//Main code													   
//------------------------------------------------------------
void main(void)
{																   

	vec2 tex_coord = gl_TexCoord[0].st;
	float posX = gl_TexCoord[0].s;
	float posY = gl_TexCoord[0].t;
	vec4 src_color = TextureValue(posX, posY,0.0,0.0);//texture2D(texUnit, tex_coord).rgba;
	
	if(effectenable == 0)
	{
		gl_FragColor = src_color;
		return;
	}
	
	src_color = ApplyFilter(src_color);
	
	if(denoise == 1)
	{
		src_color = Denoise(src_color);
	}

	if(filmgrain == 1)
	{
		vec4 noise = vec4(pnoise3D(vec3(tex_coord*vec2(fWidth,fHeight),0.0)));
	  
		if(grayscale == 0)
		{
			noise.g = pnoise3D(vec3(tex_coord*vec2(fWidth,fHeight),1.0));
			noise.b = pnoise3D(vec3(tex_coord*vec2(fWidth,fHeight),2.0));
		}
		
		src_color = src_color+noise*grainamount;
	}


	gl_FragColor = src_color;
}


