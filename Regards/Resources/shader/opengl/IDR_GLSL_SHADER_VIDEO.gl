uniform sampler2D texUnit;
uniform float fWidth;
uniform float fHeight;
uniform int effectenable;
uniform int grayscale;
uniform int sharpenMasking;
uniform int tone;
uniform int colorboost;
uniform int denoise;
uniform float sharpness;
uniform float contrast;
uniform float brightness;
uniform float red;
uniform float green;
uniform float blue;

uniform float sigma;
uniform float threshold;
uniform float kSigma;


#define INV_SQRT_OF_2PI 0.39894228040143267793994605993439  // 1.0/SQRT_OF_2PI
#define INV_PI 0.31830988618379067153776752674503
//  smartDeNoise - parameters
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//  sampler2D tex     - sampler image / texture
//  vec2 uv           - actual fragment coord
//  float sigma  >  0 - sigma Standard Deviation
//  float kSigma >= 0 - sigma coefficient 
//      kSigma * sigma  -->  radius of the circular kernel
//  float threshold   - edge sharpening threshold 


//------------------------------------------------------------
//TextureValue													   
//------------------------------------------------------------
vec4 TextureValue(float posX, float posY, float xDiff, float yDiff)
{
	float texelSizeX = 1.0 / fWidth; //size of one texel 
	float texelSizeY = 1.0 / fHeight; //size of one texel 
	vec2 resolution = vec2(texelSizeX, texelSizeY); 
	return texture2D(texUnit, vec2(posX,posY) + resolution * vec2(xDiff, yDiff));
}

//------------------------------------------------------------
//Denoise													   
//------------------------------------------------------------
vec4 Denoise(vec4 centrPx, sampler2D tex)
{
    float radius = round(kSigma*sigma);
    float radQ = radius * radius;

    float invSigmaQx2 = .5 / (sigma * sigma);      // 1.0 / (sigma^2 * 2.0)
    float invSigmaQx2PI = INV_PI * invSigmaQx2;    // // 1/(2 * PI * sigma^2)

    float invThresholdSqx2 = .5 / (threshold * threshold);     // 1.0 / (sigma^2 * 2.0)
    float invThresholdSqrt2PI = INV_SQRT_OF_2PI / threshold;   // 1.0 / (sqrt(2*PI) * sigma)

    float zBuff = 0.0;
    vec4 aBuff = vec4(0.0);
	
	float posX = gl_TexCoord[0].s;
	float posY = gl_TexCoord[0].t;	

    vec2 d;
    for (d.x=-radius; d.x <= radius; d.x++) {
        float pt = sqrt(radQ-d.x*d.x);       // pt = yRadius: have circular trend
        for (d.y=-pt; d.y <= pt; d.y++) {
            float blurFactor = exp( -dot(d , d) * invSigmaQx2 ) * invSigmaQx2PI;

			vec4 walkPx = ApplyFilter(TextureValue(posX, posY, d.x, d.y));
            vec4 dC = walkPx-centrPx;
            float deltaFactor = exp( -dot(dC, dC) * invThresholdSqx2) * invThresholdSqrt2PI * blurFactor;

            zBuff += deltaFactor;
            aBuff += deltaFactor*walkPx;
        }
    }
    return aBuff/zBuff;
}

//------------------------------------------------------------
//ContrastFilter													   
//------------------------------------------------------------
vec4 ContrastFilter(vec4 color,float contrast, float offset)
{
	float csupp = contrast * (offset - 256.0) + 128.0;
	
	float red = contrast * (color.r * 255.0) + csupp;
	if (red < 0.0)
		red = 0.0;
	else if (red > 255.0)
		red = 255.0;	
		
	float blue = contrast * (color.b * 255.0) + csupp;
	if (blue < 0.0)
		blue = 0.0;
	else if (blue > 255.0)
		blue = 255.0;	

	float green = contrast * (color.g * 255.0) + csupp;
	if (green < 0.0)
		green = 0.0;
	else if (green > 255.0)
		green = 255.0;

	return vec4(red / 255.0, green / 255.0, blue / 255.0, color.a);		

}

//------------------------------------------------------------
//LightnessFilter													   
//------------------------------------------------------------
vec4 LightnessFilter(vec4 color)
{
	float nChange = (2.55 * brightness) / 255.0;
	return vec4(color.r + nChange, color.g + nChange, color.b + nChange, color.a);
}

//------------------------------------------------------------
//ApplyFilter													   
//------------------------------------------------------------
vec4 ApplyFilter(vec4 src_color)
{
	//------------------------------------------------------------
	//Variable													   
	//------------------------------------------------------------
	vec2 tex_coord = gl_TexCoord[0].st;
		
	if(sharpenMasking == 1)
	{
		vec4 sum;
		float posX = gl_TexCoord[0].s;
		float posY = gl_TexCoord[0].t;
		sum =  TextureValue(posX, posY, -1.0, -1.0);
		sum += TextureValue(posX, posY, 0.0, -1.0);
		sum += TextureValue(posX, posY, 1.0, -1.0);
		sum += TextureValue(posX, posY, -1.0, 0.0);
		sum += src_color;
		sum += TextureValue(posX, posY, 1.0, 0.0);
		sum += TextureValue(posX, posY, -1.0, 1.0);
		sum += TextureValue(posX, posY, 0.0, 1.0);
		sum += TextureValue(posX, posY, 1.0, 1.0);
		vec4 blur = sum / vec4(9.0,9.0,9.0,9.0);
		src_color = src_color + (src_color - blur) * sharpness;		
	}

	if(tone == 1)
	{
		if (contrast == 0.0)
		{
			src_color = ContrastFilter(src_color, 1.0, 128.0);
		}
		else if (contrast > 0.0)
		{
			float offset = contrast;
			offset /= 100.0;
			offset = 1.0 + offset;
			src_color = ContrastFilter(src_color, offset, 128.0);
		}
		else if (contrast < 0.0)
		{
			float offset = -contrast;
			offset /= 100.0;
			offset = 1.0 - offset;
			src_color = ContrastFilter(src_color, offset, 128.0);
		}
	
		src_color = LightnessFilter(src_color);
	}

	if(colorboost == 1)
	{
		float _localred = red / 255.0; 
		float _localgreen = green / 255.0; 
		float _localblue = blue / 255.0; 

		_localred = src_color.r + _localred;
		_localgreen = src_color.g + _localgreen;
		_localblue = src_color.b + _localblue;

		if (_localred > 1.0)
			_localred = 1.0;

		if(_localred < 0.0)
			_localred = 0.0;

		if (_localgreen > 1.0)
			_localgreen = 1.0;

		if(_localgreen < 0.0)
			_localgreen = 0.0;

		if (_localblue > 1.0)
			_localblue = 1.0;

		if(_localblue < 0.0)
			_localblue = 0.0;

		src_color = vec4(_localred, _localgreen, _localblue, src_color.a);
	}

	if(grayscale == 1)
	{
		float sum = src_color.r * 0.299 + src_color.b * 0.114 + src_color.g * 0.587;
		src_color = vec4(sum, sum, sum, src_color.a);
	}
	
	return src_color;
}


//------------------------------------------------------------
//Main code													   
//------------------------------------------------------------
void main(void)
{																   

	vec2 tex_coord = gl_TexCoord[0].st;
	vec4 src_color = texture2D(texUnit, tex_coord).rgba;
	
	if(effectenable == 0)
	{
		gl_FragColor = src_color;
		return;
	}
	
	src_color = ApplyFilter(src_color);

	if(denoise == 1)
	{
		src_color = smartDeNoise(src_color, texUnit);
	}

	gl_FragColor = src_color;
}


