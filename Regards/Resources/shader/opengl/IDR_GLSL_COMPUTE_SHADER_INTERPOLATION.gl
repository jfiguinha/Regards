#version 430

layout (local_size_x = 16, local_size_y = 16) in;

layout (rgba32f, binding = 0) uniform image2D img_output;
uniform float fWidth;
uniform float fHeight;
uniform sampler2D texUnitSrc;
uniform float fWidthSrc;
uniform float fHeightSrc;

uniform int left;
uniform int top;
uniform int bitmapWidth;
uniform int bitmapHeight;
uniform int flipH;
uniform int flipV;
uniform int angle;
uniform int type;
uniform float ratio;

//------------------------------------------------------------
//------------------------------------------------------------
//Interpolation Code												   
//------------------------------------------------------------
//------------------------------------------------------------
#define FILTER_PI 3.1415926535
#define FILTER_2PI 2.0 * 3.1415926535
#define FILTER_4PI 4.0 * 3.1415926535

// Inline device function to convert 32-bit unsigned integer to floating point rgba color 
//*****************************************************************

float BilinearFilter( float x)
{
	return (x < 1.0 ? 1.0 - x : 0.0); 
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
float GaussianFilter( float x)
{
	if (abs(x) > 1.25) 
	{
		return 0.0;
	}
	return exp(-x * x / 2.0) / sqrt (FILTER_2PI); 
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
float HammingFilter( float x)
{
	if (x > 1.0) 
	{
		return 0.0; 
	}
	float dWindow = 0.54 + 0.46 * cos (FILTER_2PI * x); 
	float dSinc = (x == 0) ? 1.0 : sin (FILTER_PI * x) / (FILTER_PI * x); 
	return dWindow * dSinc;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

float CubicFilter( float x) 
{
	if (x > 2.0) 
	{
		return 0.0; 
	}

	if (x < -2.0)
		return(0.0);
	if (x < -1.0)
		return((2.0+x)*(2.0+x)*(2.0+x)/6.0);
	if (x < 0.0)
		return((4.0+x*x*(-6.0-3.0*x))/6.0);
	if (x < 1.0)
		return((4.0+x*x*(-6.0+3.0*x))/6.0);
	if (x < 2.0)
		return((2.0-x)*(2.0-x)*(2.0-x)/6.0);
	return(0.0);

}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

float BlackmanFilter( float x) 
{
	if (x > 1.0) 
	{
		return 0.0; 
	}
	float dN = 2.0 * 1.0 + 1.0; 
	return 0.42 + 0.5 * cos(FILTER_2PI * x / ( dN - 1.0 )) + 0.08 * cos (FILTER_4PI * x / ( dN - 1.0 )); 
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
 
float QuadraticFilter( float x) 
{
	if (x > 1.5) 
	{
		return 0.0; 
	}

	if (x < -1.5)
		return(0.0);
	if (x < -0.5)
		return(0.5*(x+1.5)*(x+1.5));
	if (x < 0.5)
		return(0.75-x*x);
	if (x < 1.5)
		return(0.5*(x-1.5)*(x-1.5));
	return(0.0);

}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
float MitchellFilter( float x) 
{
	if (x > 2.0) 
		return 0.0; 

	#define B   (1.0/3.0)
	#define C   (1.0/3.0)
	#define P0  ((  6.0- 2.0*B       )/6.0)
	#define P2  ((-18.0+12.0*B+ 6.0*C)/6.0)
	#define P3  (( 12.0- 9.0*B- 6.0*C)/6.0)
	#define Q0  ((       8.0*B+24.0*C)/6.0)
	#define Q1  ((     -12.0*B-48.0*C)/6.0)
	#define Q2  ((       6.0*B+30.0*C)/6.0)
	#define Q3  ((     - 1.0*B- 6.0*C)/6.0)

	if (x < -2.0)
		return(0.0);
	if (x < -1.0)
		return(Q0-x*(Q1-x*(Q2-x*Q3)));
	if (x < 0.0)
		return(P0+x*x*(P2-x*P3));
	if (x < 1.0)
		return(P0+x*x*(P2+x*P3));
	if (x < 2.0)
		return(Q0+x*(Q1+x*(Q2+x*Q3)));
	return(0.0);

}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

float TriangleFilter( float x) 
{
	if (x > 1.0) 
		return 0.0; 
	if (x < -1.0)
		return(0.0);
	if (x < 0.0)
		return(1.0+x);
	if (x < 1.0)
		return(1.0-x);
	return(0.0);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

float CatromFilter( float x )
{
	float m_dWidth = 2.0;
	if (x > m_dWidth) 
	{
		return 0.0; 
	}

	if (x < -2.0)
		return(0.0);
	if (x < -1.0)
		return(0.5*(4.0+x*(8.0+x*(5.0+x))));
	if (x < 0.0)
		return(0.5*(2.0+x*x*(-5.0-3.0*x)));
	if (x < 1.0)
		return(0.5*(2.0+x*x*(-5.0+3.0*x)));
	if (x < 2.0)
		return(0.5*(4.0+x*(-8.0+x*(5.0-x))));
	return(0.0);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

float HanningFilter( float x )
{
	if (x > 1.0) 
	{
		return 0.0; 
	}

	return(0.54+0.46*cos(FILTER_PI*x));
}
		
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

float HermiteFilter( float x )
{
	float m_dWidth = 1.5;
	if (x > m_dWidth) 
		return 0.0; 

	if (x < -1.0)
		return(0.0);
	if (x < 0.0)
		return((2.0*(-x)-3.0)*(-x)*(-x)+1.0);
	if (x < 1.0)
		return((2.0*x-3.0)*x*x+1.0);
	return(0.0);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

float BboxFilter( float f )
{
	float width = 0.5;
	return (f <= width ? 1.0 : 0.0);
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

float KernelFilter_selection(float f)
{
	if(type == 1)
	{
		return BboxFilter(f);
	}
	else if(type == 2)
	{
		return HermiteFilter(f);
	}
	else if(type == 3)
	{
		return HanningFilter(f);
	}	
	else if(type == 4)
	{
		return CatromFilter(f);
	}		
	else if(type == 5)
	{
		return MitchellFilter(f);
	}	
	else if(type == 6)
	{
		return TriangleFilter(f);
	}	
	else if(type == 7)
	{
		return QuadraticFilter(f);
	}	
	else if(type == 8)
	{
		return BlackmanFilter(f);
	}	
	else if(type == 9)
	{
		return HammingFilter(f);
	}	
	else if(type == 10)
	{
		return GaussianFilter(f);
	}
	else if(type == 11)
	{
		return BilinearFilter(f);
	}	
	return CubicFilter(f);
}

//------------------------------------------------------------
//GetColorSrc TextureValue													   
//------------------------------------------------------------

vec4 GetColorSrc(float posX, float posY, float xDiff, float yDiff)
{
	float texelSizeX = 1.0 / fWidth; //size of one texel 
	float texelSizeY = 1.0 / fHeight; //size of one texel 
	vec2 resolution = vec2(texelSizeX, texelSizeY); 
	return texture2D(texUnit, vec2(posX,posY) + resolution * vec2(xDiff, yDiff));
}

//------------------------------------------------------------
//KernelExecution													   
//------------------------------------------------------------

vec4 KernelExecution(float x, float y)
{
	vec4 nDenom = vec4(0.0);
	float valueA = x;
	float valueB = y;
	float realA = x - valueA;
	float realB = y - valueB;
	
	vec4 fy1 = vec4(KernelFilter_selection(-(-1.0 - realB)));
	vec4 fy2 = vec4(KernelFilter_selection(realB));
	vec4 fy3 = vec4(KernelFilter_selection(-(1.0 - realB)));
	
	vec4 fx1 = vec4(KernelFilter_selection(-1.0 - realA));
	vec4 fx2 = vec4(KernelFilter_selection(- realA));
	vec4 fx3 = vec4(KernelFilter_selection(1.0 - realA));
	
	nDenom += fy1 * (fx1 + fx2 + fx3) + fy2 * (fx1 + fx2 + fx3) + fy3 * (fx1 + fx2 + fx3);

	
	vec4 sum = GetColorSrc(x, y, -1.0, -1.0) * (fy1 * fx1);
	sum += GetColorSrc(x, y, 0.0, -1.0) * (fy1 * fx2);
	sum += GetColorSrc(x, y, 1.0, -1.0) * (fy1 * fx3);
	
	sum += GetColorSrc(x, y, -1.0, 0.0) * (fy2 * fx1);
	sum += GetColorSrc(x, y, 0.0, 0.0) * (fy2 * fx2);
	sum += GetColorSrc(x, y, 1.0, 0.0) * (fy2 * fx3);

	sum += GetColorSrc(x, y, -1.0, 1.0) * (fy3 * fx1);
	sum += GetColorSrc(x, y, 0.0, 1.0) * (fy3 * fx2);
	sum += GetColorSrc(x, y, 1.0, 1.0) * (fy3 * fx3);
	
    return sum / nDenom;
}

//------------------------------------------------------------
//TextureValue													   
//------------------------------------------------------------

vec4 CalculInterpolation(float ratioX, float ratioY, vec2 positionTexture)
{
	float texelSizeX = 1.0 / fWidth; //size of one texel 
	float texelSizeY = 1.0 / fHeight; //size of one texel 
	vec2 resolution = vec2(texelSizeX, texelSizeY); 
	vec2 posResolution = resolution * vec2(left, top);

	float posX = positionTexture.x * ratioX + posResolution.x * ratioX;
	float posY = positionTexture.y * ratioY + posResolution.y * ratioY;

	if (angle == 270)
	{
		float srcx = posY;
		float srcy = posX;

		posX = srcx;
		posY = srcy;

		posX = fWidthSrc - posX - 1;
	}
	else if (angle == 180)
	{
		posX = fWidthSrc - posX - 1;
		posY = fHeightSrc - posY - 1;
	}
	else if (angle == 90)
	{
		float srcx = posY;
		float srcy = posX;

		posX = srcx;
		posY = srcy;

		posY = fHeightSrc - posY - 1;
	}
	
	if(angle == 90 || angle == 270)
	{
		if (flipV == 1)
		{
			posX = fWidthSrc - posX - 1;
		}

		if (flipH == 1)
		{
			posY = fHeightSrc - posY - 1;
		}
	
	}
	else
	{
		if (flipH == 1)
		{
			posX = fWidthSrc - posX - 1;
		}

		if (flipV == 1)
		{
			posY = fHeightSrc - posY - 1;
		}
	}

	
	if(type == 12)
		return GetColorSrc(posX, posY, 0.0, 0.0);
	return KernelExecution(posX, posY);
}

//------------------------------------------------------------
//TextureValue													   
//------------------------------------------------------------

vec4 TextureValue(float posX, float posY, float xDiff, float yDiff)
{
	vec4 color;
	float texelSizeX = 1.0 / fWidth; //size of one texel 
	float texelSizeY = 1.0 / fHeight; //size of one texel 
	vec2 positionTexture = vec2(posX,posY) + vec2(texelSizeX, texelSizeY) * vec2(xDiff, yDiff); 
	
	float srcTexelSizeX = 1.0 / fWidthSrc; //size of one texel 
	float srcTexelSizeY = 1.0 / fHeightSrc; //size of one texel 
	
	float diffx = srcTexelSizeX / texelSizeX;
	float diffy = srcTexelSizeY / texelSizeY;
	
	positionTexture.x = (positionTexture.x / texelSizeX) * srcTexelSizeX;
	positionTexture.y = (positionTexture.y / texelSizeY) * srcTexelSizeY;
	
	if(ratio == 1.0)
	{
		float ratioX = fWidthSrc / fWidth;
		float ratioY = fHeightSrc / fHeight;
		color = CalculInterpolation(ratioX, ratioY, positionTexture);
	}
	else
	{
		float ratioX = fWidthSrc / bitmapWidth;
		float ratioY = fHeightSrc / bitmapHeight;
		color = CalculInterpolation(ratioX, ratioY, positionTexture);
	}
	return color;
}

//------------------------------------------------------------
//Main code													   
//------------------------------------------------------------
void main(void)
{																   
	ivec2 coords = ivec2(gl_GlobalInvocationID);

	float posX = coords.x;
	float posY = coords.y;
	vec4 src_color = TextureValue(posX, posY,0.0,0.0);
	
	imageStore(img_output, coords, src_color);
}


