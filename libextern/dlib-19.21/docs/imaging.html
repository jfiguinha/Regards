<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html xmlns:gcse="googleCustomSearch"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link rel="shortcut icon" href="dlib-icon.ico"><meta name="verify-v1" content="02MiiaFNVzS5/u0eQhsy3/knioFHsia1X3DXRpHkE6I="><meta name="google-site-verification" content="DGSSJMKDomaDaDTIRJ8jDkv0YMx9Cz7OESbXHjjr6Jw"><title>dlib C++ Library
               - Image Processing</title><script type="text/javascript" src="dlib.js"></script><link rel="stylesheet" type="text/css" href="dlib.css"></head><body><a name="top"></a><div id="page_header"><a href="http://dlib.net"><img src="dlib-logo.png"></a></div><div id="top_content"><div id="main_menu" class="menu"><div class="menu_top"><b>The Library</b><ul class="tree"><li><a href="algorithms.html" class="menu">Algorithms</a></li><li><a href="api.html" class="menu">API Wrappers</a></li><li><a href="bayes.html" class="menu">Bayesian Nets</a></li><li><a href="compression.html" class="menu">Compression</a></li><li><a href="containers.html" class="menu">Containers</a></li><li><a href="graph_tools.html" class="menu">Graph Tools</a></li><li><a href="imaging.html" class="menu">Image Processing</a></li><li><a href="linear_algebra.html" class="menu">Linear Algebra</a></li><li><a href="ml.html" class="menu">Machine Learning</a></li><li><a href="metaprogramming.html" class="menu">Metaprogramming</a></li><li><a href="other.html" class="menu">Miscellaneous</a></li><li><a href="network.html" class="menu">Networking</a></li><li><a href="optimization.html" class="menu">Optimization</a></li><li><a href="parsing.html" class="menu">Parsing</a></li></ul><br><b>Help/Info</b><ul class="tree"><li><a href="http://blog.dlib.net" class="menu">Dlib Blog</a></li><li><a onclick="Toggle(this)" class="sub menu"><img src="plus.gif">Examples: C++</a><ul style="display:none;"><li><a href="3d_point_cloud_ex.cpp.html" class="menu">3D Point Cloud</a></li><li><a href="assignment_learning_ex.cpp.html" class="menu">Assignment Learning</a></li><li><a href="file_to_code_ex.cpp.html" class="menu">Base64 Encoder</a></li><li><a href="bayes_net_from_disk_ex.cpp.html" class="menu">Bayesian Network From Disk</a></li><li><a href="bayes_net_gui_ex.cpp.html" class="menu">Bayesian Network GUI</a></li><li><a href="bayes_net_ex.cpp.html" class="menu">Bayesian Network</a></li><li><a href="bridge_ex.cpp.html" class="menu">Bridge</a></li><li><a href="bsp_ex.cpp.html" class="menu">BSP</a></li><li><a href="svm_c_ex.cpp.html" class="menu">C-Support Vector Machine</a></li><li><a href="compress_stream_ex.cpp.html#_top" class="menu">Cmd Line Parser</a></li><li><a href="compress_stream_ex.cpp.html" class="menu">Compress Stream</a></li><li><a href="config_reader_ex.cpp.html" class="menu">Config File Reader</a></li><li><a href="custom_trainer_ex.cpp.html" class="menu">Custom Trainers</a></li><li><a href="dnn_face_recognition_ex.cpp.html" class="menu">Deep Face Recognition</a></li><li><a href="dnn_dcgan_train_ex.cpp.html" class="menu">Deep Learning DCGAN</a></li><li><a href="dnn_mmod_dog_hipsterizer.cpp.html" class="menu">Deep Learning Dog Hipsterizer</a></li><li><a href="dnn_mmod_face_detection_ex.cpp.html" class="menu">Deep Learning Face Detection</a></li><li><a href="dnn_imagenet_ex.cpp.html" class="menu">Deep Learning Imagenet Classifier</a></li><li><a href="dnn_imagenet_train_ex.cpp.html" class="menu">Deep Learning Imagenet Trainer </a></li><li><a href="dnn_inception_ex.cpp.html" class="menu">Deep Learning Inception</a></li><li><a href="dnn_instance_segmentation_train_ex.cpp.html" class="menu">Deep Learning Instance Segmentation Trainer</a></li><li><a href="dnn_instance_segmentation_ex.cpp.html" class="menu">Deep Learning Instance Segmentation</a></li><li><a href="dnn_introduction_ex.cpp.html" class="menu">Deep Learning Introduction Part 1</a></li><li><a href="dnn_introduction2_ex.cpp.html" class="menu">Deep Learning Introduction Part 2</a></li><li><a href="dnn_introduction3_ex.cpp.html" class="menu">Deep Learning Introduction Part 3</a></li><li><a href="dnn_mmod_ex.cpp.html" class="menu">Deep Learning Max-Margin Object Detection</a></li><li><a href="dnn_mmod_find_cars2_ex.cpp.html" class="menu">Deep Learning Multi-Class Vehicle Detection</a></li><li><a href="dnn_semantic_segmentation_train_ex.cpp.html" class="menu">Deep Learning Semantic Segmentation Trainer</a></li><li><a href="dnn_semantic_segmentation_ex.cpp.html" class="menu">Deep Learning Semantic Segmentation</a></li><li><a href="dnn_mmod_train_find_cars_ex.cpp.html" class="menu">Deep Learning Vehicle Detection Trainer</a></li><li><a href="dnn_mmod_find_cars_ex.cpp.html" class="menu">Deep Learning Vehicle Detection</a></li><li><a href="dnn_metric_learning_ex.cpp.html" class="menu">Deep Metric Learning Introduction</a></li><li><a href="dnn_metric_learning_on_images_ex.cpp.html" class="menu">Deep Metric Learning on Images</a></li><li><a href="dir_nav_ex.cpp.html" class="menu">Directory Navigation</a></li><li><a href="empirical_kernel_map_ex.cpp.html" class="menu">Empirical Kernel Map</a></li><li><a href="face_detection_ex.cpp.html" class="menu">Face Detection</a></li><li><a href="face_landmark_detection_ex.cpp.html" class="menu">Face Landmark Detection</a></li><li><a href="fhog_ex.cpp.html" class="menu">FHOG Feature Extraction</a></li><li><a href="fhog_object_detector_ex.cpp.html" class="menu">FHOG Object Detection</a></li><li><a href="graph_labeling_ex.cpp.html" class="menu">Graph Labeling</a></li><li><a href="gui_api_ex.cpp.html" class="menu">GUI</a></li><li><a href="hough_transform_ex.cpp.html" class="menu">Hough Transform</a></li><li><a href="server_http_ex.cpp.html" class="menu">HTTP Server</a></li><li><a href="image_ex.cpp.html" class="menu">Image</a></li><li><a href="iosockstream_ex.cpp.html" class="menu">IO Socket Streams</a></li><li><a href="server_iostream_ex.cpp.html" class="menu">IO Streams Server</a></li><li><a href="kcentroid_ex.cpp.html" class="menu">Kernel Centroid</a></li><li><a href="kkmeans_ex.cpp.html" class="menu">Kernel K-Means Clustering</a></li><li><a href="krr_regression_ex.cpp.html" class="menu">Kernel Ridge Regression</a></li><li><a href="krls_filter_ex.cpp.html" class="menu">Kernel RLS Filtering</a></li><li><a href="krls_ex.cpp.html" class="menu">Kernel RLS Regression</a></li><li><a href="krr_classification_ex.cpp.html" class="menu">KRR Classification</a></li><li><a href="learning_to_track_ex.cpp.html" class="menu">Learning to Track</a></li><li><a href="max_cost_assignment_ex.cpp.html" class="menu">Linear Assignment Problems</a></li><li><a href="linear_manifold_regularizer_ex.cpp.html" class="menu">Linear Manifold Regularizer</a></li><li><a href="mpc_ex.cpp.html" class="menu">Linear Model Predictive Control</a></li><li><a href="logger_ex_2.cpp.html" class="menu">Logger Advanced</a></li><li><a href="logger_custom_output_ex.cpp.html" class="menu">Logger Custom Output</a></li><li><a href="logger_ex.cpp.html" class="menu">Logger</a></li><li><a href="matrix_expressions_ex.cpp.html" class="menu">Matrix Expressions</a></li><li><a href="matrix_ex.cpp.html" class="menu">Matrix</a></li><li><a href="member_function_pointer_ex.cpp.html" class="menu">Member Function Pointer</a></li><li><a href="model_selection_ex.cpp.html" class="menu">Model Selection</a></li><li><a href="multiclass_classification_ex.cpp.html" class="menu">Multiclass Classification</a></li><li><a href="multithreaded_object_ex.cpp.html" class="menu">Multithreaded Object</a></li><li><a href="mlp_ex.cpp.html" class="menu">Neural Network</a></li><li><a href="least_squares_ex.cpp.html" class="menu">Non-Linear Least Squares</a></li><li><a href="svm_ex.cpp.html" class="menu">Nu-Support Vector Machine</a></li><li><a href="integrate_function_adapt_simp_ex.cpp.html" class="menu">Numerical Integration</a></li><li><a href="object_detector_advanced_ex.cpp.html" class="menu">Object Detector Advanced</a></li><li><a href="object_detector_ex.cpp.html" class="menu">Object Detector</a></li><li><a href="one_class_classifiers_ex.cpp.html" class="menu">One Class Classifiers</a></li><li><a href="svm_pegasos_ex.cpp.html" class="menu">Online SVM</a></li><li><a href="optimization_ex.cpp.html" class="menu">Optimization</a></li><li><a href="parallel_for_ex.cpp.html" class="menu">Parallel For Loops</a></li><li><a href="pipe_ex_2.cpp.html" class="menu">Pipe 2</a></li><li><a href="pipe_ex.cpp.html" class="menu">Pipe</a></li><li><a href="quantum_computing_ex.cpp.html" class="menu">Quantum Computing</a></li><li><a href="queue_ex.cpp.html" class="menu">Queue</a></li><li><a href="random_cropper_ex.cpp.html" class="menu">Random Cropper</a></li><li><a href="rank_features_ex.cpp.html" class="menu">Rank Features</a></li><li><a href="rvm_ex.cpp.html" class="menu">Relevance Vector Classification</a></li><li><a href="rvm_regression_ex.cpp.html" class="menu">Relevance Vector Regression</a></li><li><a href="running_stats_ex.cpp.html" class="menu">Running Stats</a></li><li><a href="sequence_labeler_ex.cpp.html" class="menu">Sequence Labeling</a></li><li><a href="sequence_segmenter_ex.cpp.html" class="menu">Sequence Segmentation</a></li><li><a href="sockets_ex.cpp.html" class="menu">Sockets</a></li><li><a href="sockstreambuf_ex.cpp.html" class="menu">Sockstreambuf</a></li><li><a href="svm_sparse_ex.cpp.html" class="menu">Sparse Vectors</a></li><li><a href="sqlite_ex.cpp.html" class="menu">SQLite</a></li><li><a href="std_allocator_ex.cpp.html" class="menu">Std C++ Allocator</a></li><li><a href="svm_struct_ex.cpp.html" class="menu">Structural Support Vector Machines</a></li><li><a href="svr_ex.cpp.html" class="menu">Support Vector Regression</a></li><li><a href="surf_ex.cpp.html" class="menu">SURF</a></li><li><a href="svm_rank_ex.cpp.html" class="menu">SVM-Rank</a></li><li><a href="thread_function_ex.cpp.html" class="menu">Thread Function</a></li><li><a href="thread_pool_ex.cpp.html" class="menu">Thread Pool</a></li><li><a href="threaded_object_ex.cpp.html" class="menu">Threaded Object</a></li><li><a href="threads_ex.cpp.html" class="menu">Threads</a></li><li><a href="timer_ex.cpp.html" class="menu">Timer</a></li><li><a href="train_object_detector.cpp.html" class="menu">Train Object Detector</a></li><li><a href="train_shape_predictor_ex.cpp.html" class="menu">Train Shape Predictor</a></li><li><a href="using_custom_kernels_ex.cpp.html" class="menu">Using Custom Kernels</a></li><li><a href="video_tracking_ex.cpp.html" class="menu">Video Object Tracking</a></li><li><a href="webcam_face_pose_ex.cpp.html" class="menu">Webcam Face Pose Estimation</a></li><li><a href="xml_parser_ex.cpp.html" class="menu">XML Parser</a></li></ul></li><li><a onclick="Toggle(this)" class="sub menu"><img src="plus.gif">Examples: Python</a><ul style="display:none;"><li><a href="svm_binary_classifier.py.html" class="menu">Binary Classification</a></li><li><a href="cnn_face_detector.py.html" class="menu">CNN Face Detector</a></li><li><a href="face_alignment.py.html" class="menu">Face Alignment</a></li><li><a href="face_clustering.py.html" class="menu">Face Clustering</a></li><li><a href="face_detector.py.html" class="menu">Face Detector</a></li><li><a href="face_jitter.py.html" class="menu">Face Jittering/Augmentation</a></li><li><a href="face_landmark_detection.py.html" class="menu">Face Landmark Detection</a></li><li><a href="face_recognition.py.html" class="menu">Face Recognition</a></li><li><a href="find_candidate_object_locations.py.html" class="menu">Find Candidate Object Locations</a></li><li><a href="global_optimization.py.html" class="menu">Global Optimization</a></li><li><a href="max_cost_assignment.py.html" class="menu">Linear Assignment Problems</a></li><li><a href="sequence_segmenter.py.html" class="menu">Sequence Segmenter</a></li><li><a href="svm_struct.py.html" class="menu">Structural Support Vector Machines</a></li><li><a href="svm_rank.py.html" class="menu">SVM-Rank</a></li><li><a href="train_object_detector.py.html" class="menu">Train Object Detector</a></li><li><a href="train_shape_predictor.py.html" class="menu">Train Shape Predictor</a></li><li><a href="correlation_tracker.py.html" class="menu">Video Object Tracking</a></li></ul></li><li><a href="faq.html" class="menu">FAQ</a></li><li><a href="index.html" class="menu">Home</a></li><li><a href="compile.html" class="menu">How to compile</a></li><li><a href="howto_contribute.html" class="menu">How to contribute</a></li><li><a href="term_index.html" class="menu">Index</a></li><li><a href="intro.html" class="menu">Introduction</a></li><li><a href="license.html" class="menu">License</a></li><li><a href="python/index.html" class="menu">Python API</a></li><li><a href="books.html" class="menu">Suggested Books</a></li><li><a href="http://sourceforge.net/p/dclib/wiki/Known_users/" class="menu">Who uses dlib?</a></li></ul><br><b>Current Release</b><ul class="tree"><li><a href="change_log.html" class="menu">Change Log</a></li><li><a href="release_notes.html" class="menu">Release Notes</a></li><li>Version: 19.21</li></ul><br></div><div class="menu_footer">
      Last Modified:<br>Aug 07, 2020</div></div><div id="main_text"><div id="main_text_title">Image Processing</div><div id="main_text_body"><p>
            This page documents the functionality present in this library that deals with the
            management and manipulation of images.  One thing to note is that there is no 
            explicit image object.  Instead, everything deals with <a href="containers.html#array2d">
            array2d</a> objects that contain various kinds of pixels or user defined <a href="dlib/image_processing/generic_image.h.html">
            generic image</a> objects.  
         </p><p><a name="Pixel%20Types"></a><h2>Pixel Types</h2>
            Most image handling routines in dlib will accept images containing any pixel type. 
            This is made possible by defining a traits class, <a href="#pixel_traits">pixel_traits</a>, for 
            each possible pixel type.  This traits class enables image processing routines to determine
            how to handle each kind of pixel and therefore only pixels which have a pixel_traits definition
            may be used.  The following list defines all the pixel types which come with pixel_traits definitions.  
            <ul><li><b>RGB</b><ul> There are two RGB pixel types in dlib, <a href="#rgb_pixel">rgb_pixel</a> and <a href="#bgr_pixel">bgr_pixel</a>.  
                  Each defines a 24bit RGB pixel type.  The bgr_pixel is identical to rgb_pixel except that it lays
                  the color channels down in memory in BGR order rather than RGB order and is therefore useful
                  for interfacing with other image processing tools which expect this format (e.g. <a href="#cv_image">OpenCV</a>). </ul></li><li><b>RGB Alpha</b><ul>The <a href="#rgb_alpha_pixel">rgb_alpha_pixel</a> is an 8bit per channel RGB pixel with an 8bit alpha channel.</ul></li><li><b>HSI</b><ul>The <a href="#hsi_pixel">hsi_pixel</a> is a 24bit pixel which represents a point in the Hue Saturation Intensity 
                  (HSI) color space. </ul></li><li><b>LAB</b><ul>The <a href="#lab_pixel">lab_pixel</a> is a 24bit pixel which represents a point in the CIELab color space. </ul></li><li><b>Grayscale</b><ul>Any built in scalar type may be used as a grayscale pixel type.  For example, unsigned char, int, double, etc.</ul></li></ul></p><p><a name="Object%20Detection"></a><h2>Object Detection</h2>
            If you want to create object detectors then try the 
            <a href="#scan_fhog_pyramid">scan_fhog_pyramid</a> tool first.  It is quite
            easy to use and train and will, in many cases, give excellent results.  If that
            doesn't give good results then try the more powerful 
            <a href="ml.html#loss_mmod_">convolutional neural network</a> based detector.
         </p></div></div><div id="right_menu" class="menu"><div class="menu_top"><b>Pixels</b><ul class="tree"><li><a href="#assign_pixel" class="menu">assign_pixel</a></li><li><a href="#assign_pixel_intensity" class="menu">assign_pixel_intensity</a></li><li><a href="#bgr_pixel" class="menu">bgr_pixel</a></li><li><a href="#get_pixel_intensity" class="menu">get_pixel_intensity</a></li><li><a href="#hsi_pixel" class="menu">hsi_pixel</a></li><li><a href="#lab_pixel" class="menu">lab_pixel</a></li><li><a href="#pixel_traits" class="menu">pixel_traits</a></li><li><a href="#rgb_alpha_pixel" class="menu">rgb_alpha_pixel</a></li><li><a href="#rgb_pixel" class="menu">rgb_pixel</a></li></ul><br><b>Image I/O</b><ul class="tree"><li><a href="#jpeg_loader" class="menu">jpeg_loader</a></li><li><a href="#load_bmp" class="menu">load_bmp</a></li><li><a href="#load_dng" class="menu">load_dng</a></li><li><a href="#load_image" class="menu">load_image</a></li><li><a href="#load_jpeg" class="menu">load_jpeg</a></li><li><a href="#load_png" class="menu">load_png</a></li><li><a href="#png_loader" class="menu">png_loader</a></li><li><a href="#save_bmp" class="menu">save_bmp</a></li><li><a href="#save_dng" class="menu">save_dng</a></li><li><a href="#save_jpeg" class="menu">save_jpeg</a></li><li><a href="#save_png" class="menu">save_png</a></li></ul><br><b>Object Detection</b><ul class="tree"><li><a href="#correlation_tracker" class="menu">correlation_tracker</a></li><li><a href="#evaluate_detectors" class="menu">evaluate_detectors</a></li><li><a href="#find_candidate_object_locations" class="menu">find_candidate_object_locations</a></li><li><a href="#find_peaks" class="menu">find_peaks</a></li><li><a href="#find_points_above_thresh" class="menu">find_points_above_thresh</a></li><li><a href="#full_object_detection" class="menu">full_object_detection</a></li><li><a href="#get_frontal_face_detector" class="menu">get_frontal_face_detector</a></li><li><a href="#min_barrier_distance" class="menu">min_barrier_distance</a></li><li><a href="#mmod_rect" class="menu">mmod_rect</a></li><li><a href="#object_detector" class="menu">object_detector</a></li><li><a href="#remove_unobtainable_rectangles" class="menu">remove_unobtainable_rectangles</a></li><li><a onclick="Toggle(this)" class="sub menu"><img src="plus.gif">Scan Image Pyramid Tools</a><ul style="display:none;"><li><a href="#compute_box_dimensions" class="menu">compute_box_dimensions</a></li><li><a href="#create_grid_detection_template" class="menu">create_grid_detection_template</a></li><li><a href="#create_overlapped_2x2_detection_template" class="menu">create_overlapped_2x2_detection_template</a></li><li><a href="#create_single_box_detection_template" class="menu">create_single_box_detection_template</a></li><li><a href="#determine_object_boxes" class="menu">determine_object_boxes</a></li><li><a href="#setup_grid_detection_templates" class="menu">setup_grid_detection_templates</a></li><li><a href="#setup_grid_detection_templates_verbose" class="menu">setup_grid_detection_templates_verbose</a></li></ul></li><li><a href="#scan_fhog_pyramid" class="menu">scan_fhog_pyramid</a></li><li><a href="#scan_image" class="menu">scan_image</a></li><li><a href="#scan_image_boxes" class="menu">scan_image_boxes</a></li><li><a href="#scan_image_custom" class="menu">scan_image_custom</a></li><li><a href="#scan_image_movable_parts" class="menu">scan_image_movable_parts</a></li><li><a href="#scan_image_pyramid" class="menu">scan_image_pyramid</a></li><li><a href="#setup_hashed_features" class="menu">setup_hashed_features</a></li><li><a href="#test_box_overlap" class="menu">test_box_overlap</a></li></ul><br><b>Feature Extraction</b><ul class="tree"><li><a href="#binned_vector_feature_image" class="menu">binned_vector_feature_image</a></li><li><a href="#extract_fhog_features" class="menu">extract_fhog_features</a></li><li><a href="#extract_highdim_face_lbp_descriptors" class="menu">extract_highdim_face_lbp_descriptors</a></li><li><a href="#extract_histogram_descriptors" class="menu">extract_histogram_descriptors</a></li><li><a href="#extract_uniform_lbp_descriptors" class="menu">extract_uniform_lbp_descriptors</a></li><li><a href="#find_bright_keypoints" class="menu">find_bright_keypoints</a></li><li><a href="#find_dark_keypoints" class="menu">find_dark_keypoints</a></li><li><a href="#fine_hog_image" class="menu">fine_hog_image</a></li><li><a href="#get_surf_points" class="menu">get_surf_points</a></li><li><a href="#hashed_feature_image" class="menu">hashed_feature_image</a></li><li><a href="#hog_image" class="menu">hog_image</a></li><li><a href="#make_uniform_lbp_image" class="menu">make_uniform_lbp_image</a></li><li><a href="#nearest_neighbor_feature_image" class="menu">nearest_neighbor_feature_image</a></li><li><a href="#poly_image" class="menu">poly_image</a></li><li><a href="#randomly_sample_image_features" class="menu">randomly_sample_image_features</a></li><li><a href="#shape_predictor" class="menu">shape_predictor</a></li><li><a onclick="Toggle(this)" class="sub menu"><img src="plus.gif">SURF Tools</a><ul style="display:none;"><li><a href="#compute_dominant_angle" class="menu">compute_dominant_angle</a></li><li><a href="#compute_surf_descriptor" class="menu">compute_surf_descriptor</a></li><li><a href="#draw_surf_points" class="menu">draw_surf_points</a></li><li><a href="#get_interest_points" class="menu">get_interest_points</a></li><li><a href="#haar_x" class="menu">haar_x</a></li><li><a href="#haar_y" class="menu">haar_y</a></li><li><a href="#hessian_pyramid" class="menu">hessian_pyramid</a></li><li><a href="#interest_point" class="menu">interest_point</a></li><li><a href="#surf_point" class="menu">surf_point</a></li></ul></li></ul><br><b>Edges and Thresholds</b><ul class="tree"><li><a href="#edge_orientation" class="menu">edge_orientation</a></li><li><a href="#find_bright_lines" class="menu">find_bright_lines</a></li><li><a href="#find_dark_lines" class="menu">find_dark_lines</a></li><li><a href="#hough_transform" class="menu">hough_transform</a></li><li><a href="#hysteresis_threshold" class="menu">hysteresis_threshold</a></li><li><a href="#image_gradients" class="menu">image_gradients</a></li><li><a href="#normalize_image_gradients" class="menu">normalize_image_gradients</a></li><li><a href="#partition_pixels" class="menu">partition_pixels</a></li><li><a href="#remove_incoherent_edge_pixels" class="menu">remove_incoherent_edge_pixels</a></li><li><a href="#sobel_edge_detector" class="menu">sobel_edge_detector</a></li><li><a href="#suppress_non_maximum_edges" class="menu">suppress_non_maximum_edges</a></li><li><a href="#threshold_image" class="menu">threshold_image</a></li></ul><br><b>Morphology</b><ul class="tree"><li><a href="#binary_close" class="menu">binary_close</a></li><li><a href="#binary_complement" class="menu">binary_complement</a></li><li><a href="#binary_difference" class="menu">binary_difference</a></li><li><a href="#binary_dilation" class="menu">binary_dilation</a></li><li><a href="#binary_erosion" class="menu">binary_erosion</a></li><li><a href="#binary_intersection" class="menu">binary_intersection</a></li><li><a href="#binary_open" class="menu">binary_open</a></li><li><a href="#binary_union" class="menu">binary_union</a></li><li><a href="#encode_8_pixel_neighbors" class="menu">encode_8_pixel_neighbors</a></li><li><a href="#find_line_endpoints" class="menu">find_line_endpoints</a></li><li><a href="#label_connected_blobs" class="menu">label_connected_blobs</a></li><li><a href="#label_connected_blobs_watershed" class="menu">label_connected_blobs_watershed</a></li><li><a href="#segment_image" class="menu">segment_image</a></li><li><a href="#skeleton" class="menu">skeleton</a></li></ul><br><b>Filtering</b><ul class="tree"><li><a href="#float_spatially_filter_image_separable" class="menu">float_spatially_filter_image_separable</a></li><li><a href="#gaussian_blur" class="menu">gaussian_blur</a></li><li><a href="#max_filter" class="menu">max_filter</a></li><li><a href="#separable_3x3_filter_block_grayscale" class="menu">separable_3x3_filter_block_grayscale</a></li><li><a href="#separable_3x3_filter_block_rgb" class="menu">separable_3x3_filter_block_rgb</a></li><li><a href="#spatially_filter_image" class="menu">spatially_filter_image</a></li><li><a href="#spatially_filter_image_separable" class="menu">spatially_filter_image_separable</a></li><li><a href="#spatially_filter_image_separable_down" class="menu">spatially_filter_image_separable_down</a></li><li><a href="#sum_filter" class="menu">sum_filter</a></li><li><a href="#sum_filter_assign" class="menu">sum_filter_assign</a></li></ul><br><b>Scaling and Rotating</b><ul class="tree"><li><a href="#add_image_left_right_flips" class="menu">add_image_left_right_flips</a></li><li><a href="#add_image_rotations" class="menu">add_image_rotations</a></li><li><a href="#create_tiled_pyramid" class="menu">create_tiled_pyramid</a></li><li><a href="#extract_image_4points" class="menu">extract_image_4points</a></li><li><a href="#extract_image_chips" class="menu">extract_image_chips</a></li><li><a href="#flip_image_dataset_left_right" class="menu">flip_image_dataset_left_right</a></li><li><a href="#flip_image_left_right" class="menu">flip_image_left_right</a></li><li><a href="#flip_image_up_down" class="menu">flip_image_up_down</a></li><li><a href="#interpolate_bilinear" class="menu">interpolate_bilinear</a></li><li><a href="#interpolate_nearest_neighbor" class="menu">interpolate_nearest_neighbor</a></li><li><a href="#interpolate_quadratic" class="menu">interpolate_quadratic</a></li><li><a href="#jitter_image" class="menu">jitter_image</a></li><li><a href="#pyramid_disable" class="menu">pyramid_disable</a></li><li><a href="#pyramid_down" class="menu">pyramid_down</a></li><li><a href="#pyramid_up" class="menu">pyramid_up</a></li><li><a href="#random_cropper" class="menu">random_cropper</a></li><li><a href="#resize_image" class="menu">resize_image</a></li><li><a href="#rotate_image" class="menu">rotate_image</a></li><li><a href="#rotate_image_dataset" class="menu">rotate_image_dataset</a></li><li><a href="#sub_image" class="menu">sub_image</a></li><li><a href="#transform_image" class="menu">transform_image</a></li><li><a href="#upsample_image_dataset" class="menu">upsample_image_dataset</a></li></ul><br><b>Visualization</b><ul class="tree"><li><a href="#draw_fhog" class="menu">draw_fhog</a></li><li><a href="#draw_line" class="menu">draw_line</a></li><li><a href="#draw_rectangle" class="menu">draw_rectangle</a></li><li><a href="#draw_solid_circle" class="menu">draw_solid_circle</a></li><li><a href="#draw_surf_points" class="menu">draw_surf_points</a></li><li><a href="#fill_rect" class="menu">fill_rect</a></li><li><a href="#heatmap" class="menu">heatmap</a></li><li><a href="#jet" class="menu">jet</a></li><li><a href="#randomly_color_image" class="menu">randomly_color_image</a></li><li><a href="#render_face_detections" class="menu">render_face_detections</a></li><li><a href="#tile_images" class="menu">tile_images</a></li></ul><br><b>Miscellaneous</b><ul class="tree"><li><a href="#assign_all_pixels" class="menu">assign_all_pixels</a></li><li><a href="#assign_border_pixels" class="menu">assign_border_pixels</a></li><li><a href="#assign_image" class="menu">assign_image</a></li><li><a href="#assign_image_scaled" class="menu">assign_image_scaled</a></li><li><a href="#cv_image" class="menu">cv_image</a></li><li><a href="#disturb_colors" class="menu">disturb_colors</a></li><li><a href="#equalize_histogram" class="menu">equalize_histogram</a></li><li><a href="#get_histogram" class="menu">get_histogram</a></li><li><a href="#integral_image" class="menu">integral_image</a></li><li><a href="#integral_image_generic" class="menu">integral_image_generic</a></li><li><a href="#random_color_transform" class="menu">random_color_transform</a></li><li><a href="#toMat" class="menu">toMat</a></li><li><a href="#zero_border_pixels" class="menu">zero_border_pixels</a></li></ul><br></div><div class="menu_footer"></div></div></div><div id="bottom_content"><a name="add_image_left_right_flips"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">add_image_left_right_flips</h1><BR><BR>        
            This routine takes a set of images and bounding boxes within those
            images and doubles the size of the dataset by adding left/right
            flipped copies of each image as well as the corresponding bounding
            boxes.  Therefore, this function is useful if you are training and
            object detector and your objects have a left/right symmetry.  
         <BR><BR>C++ Example Programs: <a href="fhog_object_detector_ex.cpp.html">fhog_object_detector_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/interpolation_abstract.h.html#add_image_left_right_flips">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="add_image_rotations"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">add_image_rotations</h1><BR><BR>        
            This routine takes a set of images and bounding boxes within those images and
            grows the dataset by computing many different rotations of each image.  It will
            also adjust the positions of the bounding boxes so that they still fall on the
            same objects in each rotated image.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/interpolation_abstract.h.html#add_image_rotations">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="assign_all_pixels"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">assign_all_pixels</h1><BR><BR>        
            This global function assigns all the pixels in an image a specific value.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/assign_image_abstract.h.html#assign_all_pixels">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="assign_border_pixels"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">assign_border_pixels</h1><BR><BR>        
            This global function assigns all the pixels in the border of an image to 
            a specific value.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/assign_image_abstract.h.html#assign_border_pixels">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="assign_image"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">assign_image</h1><BR><BR>        
            This global function copies one image into another and performs any
            necessary color space conversions to make it work right. 
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/assign_image_abstract.h.html#assign_image">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="assign_image_scaled"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">assign_image_scaled</h1><BR><BR>        
            This global function copies one image into another and performs any
            necessary color space conversions to make it work right.  Additionally,
            if the dynamic range of the source image is too big to fit into the destination image
            then it will attempt to perform the appropriate scaling.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/assign_image_abstract.h.html#assign_image_scaled">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="assign_pixel"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">assign_pixel</h1><BR><BR>
            assign_pixel() is a templated function that can assign any pixel type to another pixel type.
            It will perform whatever conversion is necessary to make the assignment work.  (E.g. color to 
            grayscale conversion)
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/pixel.h.html#assign_pixel">More Details...</a><div class="include_file">#include &lt;dlib/pixel.h&gt;</div></div></div><a name="assign_pixel_intensity"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">assign_pixel_intensity</h1><BR><BR>
            assign_pixel_intensity() is a templated function that can change the
            intensity of a pixel.  So if the pixel in question is a grayscale pixel
            then it simply assigns that pixel the given value.  However, if the
            pixel is not a grayscale pixel then it converts the pixel to the
            HSI color space and sets the I channel to the given intensity
            and then converts this HSI value back to the original pixel's 
            color space.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/pixel.h.html#assign_pixel_intensity">More Details...</a><div class="include_file">#include &lt;dlib/pixel.h&gt;</div></div></div><a name="bgr_pixel"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">bgr_pixel</h1><BR><BR>
            This is a simple struct that represents a BGR colored graphical pixel.  
            <p>
            The difference between this object and the <a href="#rgb_pixel">rgb_pixel</a>
            is just that this struct lays its pixels down in memory in BGR order rather
            than RGB order.  You only care about this if you are doing something like
            using the <a href="#cv_image">cv_image</a> object to map an OpenCV image
            into a more object oriented form.
            </p><BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/pixel.h.html#bgr_pixel">More Details...</a><div class="include_file">#include &lt;dlib/pixel.h&gt;</div></div></div><a name="binary_close"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">binary_close</h1><BR><BR>        
            This global function performs a morphological closing on an image. 
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/morphological_operations_abstract.h.html#binary_close">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="binary_complement"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">binary_complement</h1><BR><BR>        
            This global function computes the complement of a binary image. 
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/morphological_operations_abstract.h.html#binary_complement">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="binary_difference"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">binary_difference</h1><BR><BR>        
            This global function computes the difference of two binary images. 
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/morphological_operations_abstract.h.html#binary_difference">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="binary_dilation"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">binary_dilation</h1><BR><BR>        
            This global function performs the morphological operation of dilation on an image. 
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/morphological_operations_abstract.h.html#binary_dilation">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="binary_erosion"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">binary_erosion</h1><BR><BR>        
            This global function performs the morphological operation of erosion on an image. 
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/morphological_operations_abstract.h.html#binary_erosion">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="binary_intersection"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">binary_intersection</h1><BR><BR>        
            This global function computes the intersection of two binary images. 
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/morphological_operations_abstract.h.html#binary_intersection">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="binary_open"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">binary_open</h1><BR><BR>        
            This global function performs a morphological opening on an image. 
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/morphological_operations_abstract.h.html#binary_open">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="binary_union"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">binary_union</h1><BR><BR>        
            This global function computes the union of two binary images. 
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/morphological_operations_abstract.h.html#binary_union">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="binned_vector_feature_image"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">binned_vector_feature_image</h1><BR><BR>
                This object is a tool for performing image feature extraction.  In
                particular, it wraps another image feature extractor and converts the
                wrapped image feature vectors into a high dimensional sparse vector.  For
                example, if the lower level feature extractor outputs the vector [3,4,5]
                and this vector is hashed into the second bin of four bins then the output
                sparse vector is:
                <blockquote>
                    [0,0,0,0, 3,4,5,1, 0,0,0,0, 0,0,0,0]. 
                </blockquote>
                That is, the output vector has a dimensionality that is equal to the number
                of hash bins times the dimensionality of the lower level vector plus one.
                The value in the extra dimension concatenated onto the end of the vector is
                always a constant value of 1 and serves as a bias value.  This means
                that, if there are N hash bins, these vectors are capable of representing N
                different linear functions, each operating on the vectors that fall into
                their corresponding hash bin.

               <br><br>
                The following feature extractors can be wrapped by the binned_vector_feature_image:
               <ul style="margin-top:0em"><li><a href="#hog_image">hog_image</a></li><li><a href="#fine_hog_image">fine_hog_image</a></li><li><a href="#poly_image">poly_image</a></li></ul><BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_keypoint/binned_vector_feature_image_abstract.h.html#binned_vector_feature_image">More Details...</a><div class="include_file">#include &lt;dlib/image_keypoint.h&gt;</div></div></div><a name="compute_box_dimensions"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">compute_box_dimensions</h1><BR><BR>        
            This function is a tool for computing a rectangle with a particular 
            width/height ratio and area.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_processing/detection_template_tools_abstract.h.html#compute_box_dimensions">More Details...</a><div class="include_file">#include &lt;dlib/image_processing.h&gt;</div></div></div><a name="compute_dominant_angle"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">compute_dominant_angle</h1><BR><BR>
            Computes and returns the dominant angle (i.e. the angle of the dominant gradient)
            at a given point and scale in an image.   This function is part of the
            main processing of the SURF algorithm.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_keypoint/surf_abstract.h.html#compute_dominant_angle">More Details...</a><div class="include_file">#include &lt;dlib/image_keypoint.h&gt;</div></div></div><a name="compute_surf_descriptor"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">compute_surf_descriptor</h1><BR><BR>
            Computes the 64 dimensional SURF descriptor vector of a box centered
              at a given center point, tilted at a given angle, and sized according to 
              a given scale.  
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_keypoint/surf_abstract.h.html#compute_surf_descriptor">More Details...</a><div class="include_file">#include &lt;dlib/image_keypoint.h&gt;</div></div></div><a name="correlation_tracker"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">correlation_tracker</h1><BR><BR>        
                This is a tool for tracking moving objects in a video stream.  You give it
                the bounding box of an object in the first frame and it attempts to track the
                object in the box from frame to frame.  

                <p>
                  This tool is an implementation of the method described in the following paper:
                  <blockquote>
                     Danelljan, Martin, et al. "Accurate scale estimation for robust visual
                     tracking." Proceedings of the British Machine Vision Conference BMVC. 2014.
                  </blockquote></p><BR><BR>C++ Example Programs: <a href="video_tracking_ex.cpp.html">video_tracking_ex.cpp</a><BR>Python Example Programs: <a href="correlation_tracker.py.html">correlation_tracker.py</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_processing/correlation_tracker_abstract.h.html#correlation_tracker">More Details...</a><div class="include_file">#include &lt;dlib/image_processing.h&gt;</div></div></div><a name="create_grid_detection_template"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">create_grid_detection_template</h1><BR><BR>        
            This function is a tool for creating a detection template usable by 
            the <a href="#scan_image_pyramid">scan_image_pyramid</a> object.  This
            particular function creates a detection template with a grid of feature
            extraction regions.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_processing/detection_template_tools_abstract.h.html#create_grid_detection_template">More Details...</a><div class="include_file">#include &lt;dlib/image_processing.h&gt;</div></div></div><a name="create_overlapped_2x2_detection_template"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">create_overlapped_2x2_detection_template</h1><BR><BR>        
            This function is a tool for creating a detection template usable by 
            the <a href="#scan_image_pyramid">scan_image_pyramid</a> object.  This
            particular function creates a detection template with four overlapping feature
            extraction regions.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_processing/detection_template_tools_abstract.h.html#create_overlapped_2x2_detection_template">More Details...</a><div class="include_file">#include &lt;dlib/image_processing.h&gt;</div></div></div><a name="create_single_box_detection_template"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">create_single_box_detection_template</h1><BR><BR>        
            This function is a tool for creating a detection template usable by 
            the <a href="#scan_image_pyramid">scan_image_pyramid</a> object.  This
            particular function creates a detection template with exactly one feature
            extraction region.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_processing/detection_template_tools_abstract.h.html#create_single_box_detection_template">More Details...</a><div class="include_file">#include &lt;dlib/image_processing.h&gt;</div></div></div><a name="create_tiled_pyramid"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">create_tiled_pyramid</h1><BR><BR>        
            This function creates an image pyramid and packs the entire pyramid into 
            one big image.  It does this by tiling the different pyramid layers together
            and outputting the result.  Here is an example:
            <br><img src="tiled_pyramid_example.jpg" border="0" height="" width="" alt=""><br>
            
            Also, you can use the 
            <a href="dlib/image_transforms/image_pyramid_abstract.h.html#image_to_tiled_pyramid">image_to_tiled_pyramid()</a>
            and 
            <a href="dlib/image_transforms/image_pyramid_abstract.h.html#image_to_tiled_pyramid">tiled_pyramid_to_image()</a> routines
            to convert between the input image coordinate space and the tiled pyramid
            coordinate space.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/image_pyramid_abstract.h.html#create_tiled_pyramid">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="cv_image"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">cv_image</h1><BR><BR>
                This object is meant to be used as a simple wrapper around the OpenCV
                IplImage struct or Mat object.  Using this class template you can turn
                an OpenCV image into something that looks like a normal dlib style 
                image object.

               <p>
                So you should be able to use cv_image objects with many of the image
                processing functions in dlib as well as the GUI tools for displaying
                images on the screen.
               </p><p>
                  Note that you can do the reverse conversion, from dlib to OpenCV,
                  using the <a href="#toMat">toMat</a> routine.  
               </p><BR><BR>C++ Example Programs: <a href="webcam_face_pose_ex.cpp.html">webcam_face_pose_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/opencv/cv_image_abstract.h.html#cv_image">More Details...</a><div class="include_file">#include &lt;dlib/opencv.h&gt;</div></div></div><a name="determine_object_boxes"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">determine_object_boxes</h1><BR><BR>        
            The <a href="#scan_image_pyramid">scan_image_pyramid</a> object represents a sliding
            window classifier system.  For it to work correctly it needs to be given a set of
            object boxes which define the size and shape of each sliding window and these windows
            need to be able to match the sizes and shapes of targets the user wishes to detect.
            Therefore, the determine_object_boxes() routine is a tool for computing a set of object boxes
            which can meet this requirement.

         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_processing/scan_image_pyramid_tools_abstract.h.html#determine_object_boxes">More Details...</a><div class="include_file">#include &lt;dlib/image_processing.h&gt;</div></div></div><a name="disturb_colors"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">disturb_colors</h1><BR><BR>
              Applies a random color transform an image.  This is done by
              creating a <a href="#random_color_transform">random_color_transform</a> with the given parameters and then
              transforming each pixel in the image with the resulting transform.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/random_color_transform_abstract.h.html#disturb_colors">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="draw_fhog"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">draw_fhog</h1><BR><BR>        
            This function takes a FHOG feature map which was created by 
            <a href="#extract_fhog_features">extract_fhog_features</a> and
              converts it into an image suitable for display on the screen.  In
              particular, we draw all the hog cells into a grayscale image in a
              way that shows the magnitude and orientation of the gradient
              energy in each cell.  
         <BR><BR>C++ Example Programs: <a href="fhog_ex.cpp.html">fhog_ex.cpp</a>,
               <a href="fhog_object_detector_ex.cpp.html">fhog_object_detector_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/fhog_abstract.h.html#draw_fhog">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="draw_line"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">draw_line</h1><BR><BR>        
            This global function draws a line on an image.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/draw_abstract.h.html#draw_line">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="draw_rectangle"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">draw_rectangle</h1><BR><BR>        
            This global function draws a rectangle on an image.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/draw_abstract.h.html#draw_rectangle">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="draw_solid_circle"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">draw_solid_circle</h1><BR><BR>        
            This global function draws a solid circle on an image.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/draw_abstract.h.html#draw_solid_circle">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="draw_surf_points"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">draw_surf_points</h1><BR><BR>
            This routine adds a bunch of <a href="#surf_point">surf_point</a> objects onto
            an <a href="dlib/gui_widgets/widgets_abstract.h.html#image_window">image_window</a>
            object so they can be visualized.
         <BR><BR>C++ Example Programs: <a href="surf_ex.cpp.html">surf_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_keypoint/draw_surf_points_abstract.h.html#draw_surf_points">More Details...</a><div class="include_file">#include &lt;dlib/image_keypoint/draw_surf_points.h&gt;</div></div></div><a name="edge_orientation"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">edge_orientation</h1><BR><BR>        
            This global function takes horizontal and vertical gradient magnitude
            values and returns the orientation of the gradient. 
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/edge_detector_abstract.h.html#edge_orientation">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="encode_8_pixel_neighbors"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">encode_8_pixel_neighbors</h1><BR><BR>
            This routine looks at the 8 pixels immediately surrounding a pixel
            and encodes their on/off pattern into the 8 bits of an unsigned char.
            Needless to say, this routine only makes sense for binary images.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/morphological_operations_abstract.h.html#encode_8_pixel_neighbors">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="equalize_histogram"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">equalize_histogram</h1><BR><BR>        
            This global function performs histogram equalization on an image. 
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/equalize_histogram_abstract.h.html#equalize_histogram">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="evaluate_detectors"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">evaluate_detectors</h1><BR><BR>        
            This function allows you to efficiently run a bunch of
            <a href="#scan_fhog_pyramid">scan_fhog_pyramid</a> based 
            <a href="#object_detector">object_detectors</a>
            over an image.  Importantly, this function is faster than running
            each detector individually because it computes the HOG features
            only once and then reuses them for each detector.  
         <BR><BR>C++ Example Programs: <a href="fhog_object_detector_ex.cpp.html">fhog_object_detector_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_processing/scan_fhog_pyramid_abstract.h.html#evaluate_detectors">More Details...</a><div class="include_file">#include &lt;dlib/image_processing.h&gt;</div></div></div><a name="extract_fhog_features"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">extract_fhog_features</h1><BR><BR>
              This function implements the HOG feature extraction method described in 
              the paper:
                <blockquote>
                  Object Detection with Discriminatively Trained Part Based Models by
                  P. Felzenszwalb, R. Girshick, D. McAllester, D. Ramanan
                  in IEEE Transactions on Pattern Analysis and Machine Intelligence, Vol. 32, No. 9, Sep. 2010
                </blockquote>
              This means that it takes an input image and outputs Felzenszwalb's
              31 dimensional version of HOG features.
         <BR><BR>C++ Example Programs: <a href="fhog_ex.cpp.html">fhog_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/fhog_abstract.h.html#extract_fhog_features">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="extract_highdim_face_lbp_descriptors"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">extract_highdim_face_lbp_descriptors</h1><BR><BR>
              This function extracts the high-dimensional LBP feature described in the
              paper:
              <blockquote>
                Blessing of Dimensionality: High-dimensional Feature and Its Efficient
                Compression for Face Verification by Dong Chen, Xudong Cao, Fang Wen, and
                Jian Sun
              </blockquote><BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/lbp_abstract.h.html#extract_highdim_face_lbp_descriptors">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="extract_histogram_descriptors"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">extract_histogram_descriptors</h1><BR><BR>
              This function extracts histograms of pixel values from a set of windows in an
              image and returns the histograms.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/lbp_abstract.h.html#extract_histogram_descriptors">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="extract_image_4points"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">extract_image_4points</h1><BR><BR>        
            This function allows you to extract an arbitrary quadrilateral patch from
            an image.  For example, given the image on the left and the 4 corners of the
            red box you can extract the image on the right:
            <br><br><center><table><tr><td align="center"><img src="images/extract_image_4points_source.jpg" border="0" height="" width="" alt=""></td><td align="center"><img src="images/extract_image_4points_crop.jpg" border="0" height="" width="" alt=""></td></tr></table></center><BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/interpolation_abstract.h.html#extract_image_4points">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="extract_image_chips"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">extract_image_chips</h1><BR><BR>        
              This function extracts "chips" from an image.  That is, it takes a list of
              rectangular sub-windows (i.e. chips) within an image and extracts those
              sub-windows, storing each into its own image.  It also allows the user to
              specify the scale and rotation for the chip.
         <BR><BR>C++ Example Programs: <a href="face_landmark_detection_ex.cpp.html">face_landmark_detection_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/interpolation_abstract.h.html#extract_image_chips">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="extract_uniform_lbp_descriptors"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">extract_uniform_lbp_descriptors</h1><BR><BR>
              Extracts histograms of uniform local-binary-patterns from an image.  The
              histograms are from densely tiled windows that do not overlap and cover all
              of the image.
              We use the idea of uniform LBPs from the paper: 
              <blockquote>
                Face Description with Local Binary Patterns: Application to Face Recognition
                by Ahonen, Hadid, and Pietikainen.
              </blockquote><BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/lbp_abstract.h.html#extract_uniform_lbp_descriptors">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="fill_rect"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">fill_rect</h1><BR><BR>        
            This global function draws a solid rectangle on an image.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/draw_abstract.h.html#fill_rect">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="find_bright_keypoints"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">find_bright_keypoints</h1><BR><BR>
             This routine finds bright "keypoints" in an image.  In general,
             these are bright/white localized blobs.  It does this by computing
             the determinant of the image Hessian at each location and storing
             this value into an output saliency image if both eigenvalues of
             the Hessian are negative.  If either eigenvalue is positive then
             the saliency for that pixel is 0.  
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/edge_detector_abstract.h.html#find_bright_keypoints">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="find_bright_lines"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">find_bright_lines</h1><BR><BR>        
            This routine is similar to <a href="#sobel_edge_detector">sobel_edge_detector()</a>,
            except instead of finding an edge it finds a bright/white line.
            For example, the border between a black piece of paper and a white
            table is an edge, but a curve drawn with a pencil on a piece of
            paper makes a line.  
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/edge_detector_abstract.h.html#find_bright_lines">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="find_candidate_object_locations"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">find_candidate_object_locations</h1><BR><BR>        
              This function takes an input image and generates a set of candidate
              rectangles which are expected to bound any objects in the image.  It does
              this by running a version of the <a href="#segment_image">segment_image</a> routine on the image and
              then reports rectangles containing each of the segments as well as rectangles
              containing unions of adjacent segments.  The basic idea is described in the
              paper: 
              <blockquote>
                  Segmentation as Selective Search for Object Recognition by Koen E. A. van de Sande, et al.
              </blockquote>
              Note that this function deviates from what is described in the paper slightly. 
              See the code for details.
         <BR><BR>Python Example Programs: <a href="find_candidate_object_locations.py.html">find_candidate_object_locations.py</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/segment_image_abstract.h.html#find_candidate_object_locations">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="find_dark_keypoints"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">find_dark_keypoints</h1><BR><BR>
              This routine finds dark "keypoints" in an image.  In general, these are dark
              localized blobs.  It does this by computing the determinant of the image
              Hessian at each location and storing this value into an output saliency
              image if both eigenvalues of the Hessian are positive.  If either eigenvalue
              is negative then the saliency for that pixel is 0.  
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/edge_detector_abstract.h.html#find_dark_keypoints">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="find_dark_lines"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">find_dark_lines</h1><BR><BR>        
            This routine is similar to <a href="#sobel_edge_detector">sobel_edge_detector()</a>,
            except instead of finding an edge it finds a dark line.
            For example, the border between a black piece of paper and a white
            table is an edge, but a curve drawn with a pencil on a piece of
            paper makes a line.  
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/edge_detector_abstract.h.html#find_dark_lines">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="find_line_endpoints"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">find_line_endpoints</h1><BR><BR>
            This routine finds endpoints of lines in a thinned binary image.
            For example, if the image was produced by <a href="#skeleton">skeleton()</a> 
            or something like a Canny edge detector then you can use
            find_line_endpoints() to find the pixels sitting on the ends of
            lines.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/morphological_operations_abstract.h.html#find_line_endpoints">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="find_peaks"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">find_peaks</h1><BR><BR>        
            This routine finds all the points in an image with a pixel value
            above a user supplied threshold that are also local maximizers.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_processing/scan_image_abstract.h.html#find_peaks">More Details...</a><div class="include_file">#include &lt;dlib/image_processing.h&gt;</div></div></div><a name="find_points_above_thresh"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">find_points_above_thresh</h1><BR><BR>        
            This routine finds all points in an image with a pixel value above a
            threshold.  It also has the ability to produce an efficient random
            subsample of such points if the number of them is very large.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_processing/scan_image_abstract.h.html#find_points_above_thresh">More Details...</a><div class="include_file">#include &lt;dlib/image_processing.h&gt;</div></div></div><a name="fine_hog_image"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">fine_hog_image</h1><BR><BR>
            This object is a version of the <a href="#hog_image">hog_image</a> that 
            allows you to extract HOG features at a finer resolution.  
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_keypoint/fine_hog_image_abstract.h.html#fine_hog_image">More Details...</a><div class="include_file">#include &lt;dlib/image_keypoint.h&gt;</div></div></div><a name="flip_image_dataset_left_right"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">flip_image_dataset_left_right</h1><BR><BR>        
            This routine takes a set of images and bounding boxes within those images and
            mirrors the entire dataset left to right.  This means that all images are
            flipped left to right and the bounding boxes are adjusted so that they still
            sit on top of the same visual objects in the new flipped images.  
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/interpolation_abstract.h.html#flip_image_dataset_left_right">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="flip_image_left_right"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">flip_image_left_right</h1><BR><BR>        
            This is a routine which can flip an image from left to right. (e.g. as 
            if viewed through a mirror).
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/interpolation_abstract.h.html#flip_image_left_right">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="flip_image_up_down"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">flip_image_up_down</h1><BR><BR>        
            This routine flips an image upside down.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/interpolation_abstract.h.html#flip_image_up_down">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="float_spatially_filter_image_separable"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">float_spatially_filter_image_separable</h1><BR><BR>        
            This global function performs spatial filtering on an image with a user
            supplied separable filter.  It is optimized to work only on float valued 
            images with float valued filters. 
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/spatial_filtering_abstract.h.html#float_spatially_filter_image_separable">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="full_object_detection"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">full_object_detection</h1><BR><BR>        
                This object represents the location of an object in an image along with the
                positions of each of its constituent parts.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_processing/full_object_detection_abstract.h.html#full_object_detection">More Details...</a><div class="include_file">#include &lt;dlib/image_processing.h&gt;</div></div></div><a name="gaussian_blur"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">gaussian_blur</h1><BR><BR>        
            This global function blurs an image by convolving it with a Gaussian filter.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/spatial_filtering_abstract.h.html#gaussian_blur">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="get_frontal_face_detector"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">get_frontal_face_detector</h1><BR><BR>        
            This function returns an <a href="#object_detector">object_detector</a> that is
            configured to find human faces that are looking more or less towards the camera.  
            It is created using the <a href="#scan_fhog_pyramid">scan_fhog_pyramid</a>
            object.  
         <BR><BR>C++ Example Programs: <a href="face_detection_ex.cpp.html">face_detection_ex.cpp</a>,
               <a href="webcam_face_pose_ex.cpp.html">webcam_face_pose_ex.cpp</a><BR>Python Example Programs: <a href="face_detector.py.html">face_detector.py</a>,
               <div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_processing/frontal_face_detector_abstract.h.html#get_frontal_face_detector">More Details...</a><div class="include_file">#include &lt;dlib/image_processing/frontal_face_detector.h&gt;</div></div></div><a name="get_histogram"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">get_histogram</h1><BR><BR>        
            This global function computes an image's histogram and returns it in the
            form of a column or row <a href="linear_algebra.html#matrix">matrix</a> object.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/equalize_histogram_abstract.h.html#get_histogram">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="get_interest_points"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">get_interest_points</h1><BR><BR>
            This function extracts interest points from a <a href="#hessian_pyramid">hessian_pyramid</a>.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_keypoint/hessian_pyramid_abstract.h.html#get_interest_points">More Details...</a><div class="include_file">#include &lt;dlib/image_keypoint.h&gt;</div></div></div><a name="get_pixel_intensity"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">get_pixel_intensity</h1><BR><BR>
            get_pixel_intensity() is a templated function that 
            returns the grayscale intensity of a pixel.  If the pixel isn't a grayscale
            pixel then it converts the pixel to grayscale and returns that value.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/pixel.h.html#get_pixel_intensity">More Details...</a><div class="include_file">#include &lt;dlib/pixel.h&gt;</div></div></div><a name="get_surf_points"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">get_surf_points</h1><BR><BR>
             This function runs the complete SURF algorithm on an input image and 
             returns the points it found.  For a description of what exactly
             the SURF algorithm does you should read the following paper:
             <blockquote>
               SURF: Speeded Up Robust Features
               By Herbert Bay, Tinne Tuytelaars, and Luc Van Gool
             </blockquote><p>
                Also note that there are numerous flavors of the SURF algorithm
                you can put together using the functions in dlib.  The get_surf_points()
                function is just an example of one way you might do so.  
             </p><BR><BR>C++ Example Programs: <a href="surf_ex.cpp.html">surf_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_keypoint/surf_abstract.h.html#get_surf_points">More Details...</a><div class="include_file">#include &lt;dlib/image_keypoint.h&gt;</div></div></div><a name="haar_x"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">haar_x</h1><BR><BR>
            This is a function that operates on an <a href="#integral_image">integral_image</a>
            and allows you to compute the response of a Haar wavelet oriented along
            the X axis.  
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/integral_image_abstract.h.html#haar_x">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="haar_y"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">haar_y</h1><BR><BR>
            This is a function that operates on an <a href="#integral_image">integral_image</a>
            and allows you to compute the response of a Haar wavelet oriented along
            the Y axis.  
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/integral_image_abstract.h.html#haar_y">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="hashed_feature_image"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">hashed_feature_image</h1><BR><BR>
                This object is a tool for performing image feature extraction.  In
                particular, it wraps another image feature extractor and converts
                the wrapped image feature vectors into sparse indicator vectors.  It does
                this by hashing each feature vector and then returns a new vector 
                which is zero everywhere except for the position determined by the 
                hash.  

               <br><br>
                The following feature extractors can be wrapped by the hashed_feature_image:
               <ul style="margin-top:0em"><li><a href="#hog_image">hog_image</a></li><li><a href="#fine_hog_image">fine_hog_image</a></li><li><a href="#poly_image">poly_image</a></li></ul><BR><BR>C++ Example Programs: <a href="object_detector_ex.cpp.html">object_detector_ex.cpp</a>,
               <a href="train_object_detector.cpp.html">train_object_detector.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_keypoint/hashed_feature_image_abstract.h.html#hashed_feature_image">More Details...</a><div class="include_file">#include &lt;dlib/image_keypoint.h&gt;</div></div></div><a name="heatmap"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">heatmap</h1><BR><BR>
            Converts a grayscale image into a heatmap.  This is useful if you want
            to display a grayscale image with more than 256 values.  In particular,
            this function uses the following color mapping:
            <br><img src="heatmap.png" border="0" height="" width="" alt=""><BR><BR>C++ Example Programs: <a href="image_ex.cpp.html">image_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/colormaps_abstract.h.html#heatmap">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="hessian_pyramid"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">hessian_pyramid</h1><BR><BR>
                This object represents an image pyramid where each level in the
                pyramid holds determinants of Hessian matrices for the original 
                input image.  This object can be used to find stable interest
                points in an image.  

               <br><br>
                This object is an implementation of the fast Hessian pyramid 
                as described in the paper: 
                <blockquote>
                   SURF: Speeded Up Robust Features
                   By Herbert Bay, Tinne Tuytelaars, and Luc Van Gool
                </blockquote>

                This implementation was also influenced by the very well documented
                OpenSURF library and its corresponding description of how the fast
                Hessian algorithm functions:  
                <blockquote>Notes on the OpenSURF Library by Christopher Evans</blockquote><BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_keypoint/hessian_pyramid_abstract.h.html#hessian_pyramid">More Details...</a><div class="include_file">#include &lt;dlib/image_keypoint.h&gt;</div></div></div><a name="hog_image"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">hog_image</h1><BR><BR>
                This object is a tool for performing the image feature extraction algorithm
                described in the following paper:
                <blockquote>
                    Histograms of Oriented Gradients for Human Detection
                    by Navneet Dalal and Bill Triggs
                </blockquote><BR><BR>C++ Example Programs: <a href="object_detector_ex.cpp.html">object_detector_ex.cpp</a>,
               <a href="train_object_detector.cpp.html">train_object_detector.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_keypoint/hog_abstract.h.html#hog_image">More Details...</a><div class="include_file">#include &lt;dlib/image_keypoint.h&gt;</div></div></div><a name="hough_transform"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">hough_transform</h1><BR><BR>
                This object is a tool for computing the line finding version of
                the Hough transform given some kind of edge detection image as
                input.  It also allows the edge pixels to be weighted such that
                higher weighted edge pixels contribute correspondingly more to
                the output of the Hough transform, allowing stronger edges to
                create correspondingly stronger line detections in the final
                Hough transform.
         <BR><BR>C++ Example Programs: <a href="hough_transform_ex.cpp.html">hough_transform_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/hough_transform_abstract.h.html#hough_transform">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="hsi_pixel"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">hsi_pixel</h1><BR><BR>
            This is a simple struct that represents a HSI colored graphical pixel.  
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/pixel.h.html#hsi_pixel">More Details...</a><div class="include_file">#include &lt;dlib/pixel.h&gt;</div></div></div><a name="hysteresis_threshold"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">hysteresis_threshold</h1><BR><BR>        
            This global function performs hysteresis thresholding on an image. 
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/thresholding_abstract.h.html#hysteresis_threshold">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="image_gradients"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">image_gradients</h1><BR><BR>        
                This class is a tool for computing first and second derivatives of an
                image.  It does this by fitting a quadratic surface around each pixel and
                then computing the gradients of that quadratic surface.  For the details
                see the paper:
                <blockquote><a href="quadratic_image_models_IGARSS2013.pdf">Quadratic models for curved line detection in SAR CCD by Davis E. King
                     and Rhonda D. Phillips</a></blockquote>

                This technique gives very accurate gradient estimates and is
                also very fast since the entire gradient estimation procedure,
                for each type of gradient, is accomplished by cross-correlating
                the image with a single separable filter.  This means you can
                compute gradients at very large scales (e.g. by fitting the
                quadratic to a large window, like a 99x99 window) and it still
                runs very quickly.

                <p>
                   For example, the filters used to compute the X, Y, XX, XY,
                   and YY gradients at a scale of 130 are shown below:
                  <table><tr><td align="center">X:</td><td align="center"><img src="image_gradient_x.jpg" border="0" height="" width="" alt=""></td><td align="center">Y:</td><td align="center"><img src="image_gradient_y.jpg" border="0" height="" width="" alt=""></td></tr><tr><td align="center">XX:</td><td align="center"><img src="image_gradient_xx.jpg" border="0" height="" width="" alt=""></td><td align="center">XY:</td><td align="center"><img src="image_gradient_xy.jpg" border="0" height="" width="" alt=""></td><td align="center">YY:</td><td align="center"><img src="image_gradient_yy.jpg" border="0" height="" width="" alt=""></td></tr></table></p><BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/edge_detector_abstract.h.html#image_gradients">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="integral_image"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">integral_image</h1><BR><BR>
            This is a specialization of the <a href="#integral_image_generic">integral_image_generic</a>
            template for the case where sums of pixel values should be represented with 
            longs.  E.g. if you use 8bit pixels in your original images then this is
            the appropriate kind of integral image to use with them.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/integral_image_abstract.h.html">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="integral_image_generic"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">integral_image_generic</h1><BR><BR>
                This object is an alternate way of representing image data
                that allows for very fast computations of sums of pixels in 
                rectangular regions.  To use this object you load it with a
                normal image and then you can use the get_sum_of_area()
                member function to compute sums of pixels in a given area in
                constant time.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/integral_image_abstract.h.html#integral_image_generic">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="interest_point"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">interest_point</h1><BR><BR>
            This is a simple struct used to represent the interest points returned
            by the <a href="#get_interest_points">get_interest_points</a> function.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_keypoint/hessian_pyramid_abstract.h.html#interest_point">More Details...</a><div class="include_file">#include &lt;dlib/image_keypoint.h&gt;</div></div></div><a name="interpolate_bilinear"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">interpolate_bilinear</h1><BR><BR>        
                This object is a tool for performing bilinear interpolation
                on an image.  
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/interpolation_abstract.h.html#interpolate_bilinear">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="interpolate_nearest_neighbor"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">interpolate_nearest_neighbor</h1><BR><BR>        
                This object is a tool for performing nearest neighbor interpolation
                on an image.  
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/interpolation_abstract.h.html#interpolate_nearest_neighbor">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="interpolate_quadratic"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">interpolate_quadratic</h1><BR><BR>        
                This object is a tool for performing quadratic interpolation
                on an image.  
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/interpolation_abstract.h.html#interpolate_quadratic">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="jet"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">jet</h1><BR><BR>
            Converts a grayscale image into an image using the jet color
            scheme.  This is useful if you want to display a grayscale image
            with more than 256 values.   In particular, this function uses the
            following color mapping:
            <br><img src="jet.png" border="0" height="" width="" alt=""><BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/colormaps_abstract.h.html#jet">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="jitter_image"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">jitter_image</h1><BR><BR>        
            Randomly jitters an image by slightly rotating, scaling, and translating it.
            There is also a 50% chance it will be mirrored left to right.
         <BR><BR>C++ Example Programs: <a href="dnn_metric_learning_on_images_ex.cpp.html">dnn_metric_learning_on_images_ex.cpp</a>,
               <a href="dnn_face_recognition_ex.cpp.html">dnn_face_recognition_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/interpolation_abstract.h.html#jitter_image">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="jpeg_loader"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">jpeg_loader</h1><BR><BR>        
            This object loads a JPEG image file into 
            an <a href="containers.html#array2d">array2d</a> of <a href="dlib/pixel.h.html">pixels</a>.
            <p>
               Note that you must define DLIB_JPEG_SUPPORT if you want to use this object.  You
               must also set your build environment to link to the libjpeg library.  However,
               if you use CMake and dlib's default CMakeLists.txt file then it will get setup
               automatically.
            </p><BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_loader/jpeg_loader_abstract.h.html#jpeg_loader">More Details...</a><div class="include_file">#include &lt;dlib/image_io.h&gt;</div></div></div><a name="label_connected_blobs"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">label_connected_blobs</h1><BR><BR>        
              This function labels each of the connected blobs in an image with a unique integer label.  
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/label_connected_blobs_abstract.h.html#label_connected_blobs">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="label_connected_blobs_watershed"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">label_connected_blobs_watershed</h1><BR><BR>        
            This function performs a watershed segmentation of an image and
            labels each resulting flooding region with a unique integer label.

            <p>
               For example, given an image like this, which shows part of the Hubble ultra deep field:
               <center><img src="hubble_ultra_deep_field.jpg" border="0" height="" width="" alt=""></center><br>
               The algorithm would flood fill it and produce the following segmentation.  If you play
               the video you can see the actual execution of the algorithm where it starts by flooding
               from the brightest areas and progressively fills each region.
               <br><br><center><video controls="true" poster="watershed.png"><source src="watershed.webm" type="video/webm"></source><source src="watershed.mp4" type="video/mp4"></source>
                  Video of optimizer running
               </video></center></p><BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/label_connected_blobs_abstract.h.html#label_connected_blobs_watershed">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="lab_pixel"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">lab_pixel</h1><BR><BR>
            This is a simple struct that represents a CIELab colored graphical pixel.  
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/pixel.h.html#lab_pixel">More Details...</a><div class="include_file">#include &lt;dlib/pixel.h&gt;</div></div></div><a name="load_bmp"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">load_bmp</h1><BR><BR>        
      This global function loads a MS Windows BMP file into an <a href="containers.html#array2d">array2d</a> of 
      <a href="dlib/pixel.h.html">pixels</a>.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_loader/image_loader_abstract.h.html#load_bmp">More Details...</a><div class="include_file">#include &lt;dlib/image_io.h&gt;</div></div></div><a name="load_dng"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">load_dng</h1><BR><BR>        
      This global function loads a dlib DNG file (a lossless compressed image format) into 
      an <a href="containers.html#array2d">array2d</a> of <a href="dlib/pixel.h.html">pixels</a>.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_loader/image_loader_abstract.h.html#load_dng">More Details...</a><div class="include_file">#include &lt;dlib/image_io.h&gt;</div></div></div><a name="load_image"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">load_image</h1><BR><BR>        
            This global function takes a file name and
            loads it into an <a href="containers.html#array2d">array2d</a> of
            <a href="dlib/pixel.h.html">pixels</a> using the appropriate image 
            loading routine.  The supported types are BMP, PNG, JPEG, GIF, and the dlib DNG file format. 

            <p>
               Note that you can only load PNG, JPEG, and GIF files if you link against
               libpng, libjpeg, and libgif respectively.  You will also need to #define
               DLIB_PNG_SUPPORT, DLIB_JPEG_SUPPORT, and DLIB_GIF_SUPPORT.  Or use CMake and
               it will do all this for you.
            </p><BR><BR>C++ Example Programs: <a href="image_ex.cpp.html">image_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_loader/load_image_abstract.h.html#load_image">More Details...</a><div class="include_file">#include &lt;dlib/image_io.h&gt;</div></div></div><a name="load_jpeg"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">load_jpeg</h1><BR><BR>        
            This function loads a JPEG image file into 
            an <a href="containers.html#array2d">array2d</a> of <a href="dlib/pixel.h.html">pixels</a>.
            <p>
               Note that you must define DLIB_JPEG_SUPPORT if you want to use this object.  You
               must also set your build environment to link to the libjpeg library.  However,
               if you use CMake and dlib's default CMakeLists.txt file then it will get setup
               automatically.
            </p><BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_loader/jpeg_loader_abstract.h.html#load_jpeg">More Details...</a><div class="include_file">#include &lt;dlib/image_io.h&gt;</div></div></div><a name="load_png"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">load_png</h1><BR><BR>        
            This function loads a Portable Network Graphics (PNG) image file into 
            an <a href="containers.html#array2d">array2d</a> of <a href="dlib/pixel.h.html">pixels</a>.
            <p>
               Note that you must define DLIB_PNG_SUPPORT if you want to use this object.  You
               must also set your build environment to link to the libpng library.  However,
               if you use CMake and dlib's default CMakeLists.txt file then it will get setup
               automatically.
            </p><BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_loader/png_loader_abstract.h.html#load_png">More Details...</a><div class="include_file">#include &lt;dlib/image_io.h&gt;</div></div></div><a name="make_uniform_lbp_image"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">make_uniform_lbp_image</h1><BR><BR>
              This function extracts the uniform local-binary-pattern feature at every pixel
              of an image and stores the output in a new image object.  
              We use the idea of uniform LBPs from the paper: 
              <blockquote>
                Face Description with Local Binary Patterns: Application to Face Recognition
                by Ahonen, Hadid, and Pietikainen.
              </blockquote><BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/lbp_abstract.h.html#make_uniform_lbp_image">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="max_filter"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">max_filter</h1><BR><BR>        
            This function slides a rectangle over an input image and outputs a new 
            image which contains the maximum valued pixel found inside the rectangle at each
            position in the input image.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/spatial_filtering_abstract.h.html#max_filter">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="min_barrier_distance"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">min_barrier_distance</h1><BR><BR>        
            This function implements the salient object detection method described in the paper:
            <blockquote>
               "Minimum barrier salient object detection at 80 fps" by Zhang, Jianming, et al. 
            </blockquote>
            This routine takes an image as input and creates a new image where objects that are
            visually distinct from the borders of the image have bright pixels while everything else is
            dark.  This is useful because you can then threshold the resulting image to detect objects.
            For example, given the left image as input you get the right image as output:
            <br><br><center><table><tr><td align="center"><img src="images/mbd_example_in.jpg" border="0" height="" width="" alt=""></td><td align="center"><img src="images/mbd_example_out.jpg" border="0" height="" width="" alt=""></td></tr></table></center><BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/segment_image_abstract.h.html#min_barrier_distance">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="mmod_rect"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">mmod_rect</h1><BR><BR>        
                This is a simple struct that is used to give training data and receive detections
                from the <a href="ml.html#loss_mmod_">Max-Margin Object Detection loss layer</a>.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_processing/full_object_detection_abstract.h.html#mmod_rect">More Details...</a><div class="include_file">#include &lt;dlib/image_processing.h&gt;</div></div></div><a name="nearest_neighbor_feature_image"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">nearest_neighbor_feature_image</h1><BR><BR>
                This object is a tool for performing image feature extraction.  In
                particular, it wraps another image feature extractor and converts
                the wrapped image feature vectors into sparse indicator vectors.  It does
                this by finding the nearest neighbor for each feature vector and returning an
                indicator vector that is zero everywhere except for the position indicated by 
                the nearest neighbor.  

               <br><br>
               The following feature extractors can be wrapped by the nearest_neighbor_feature_image:
               <ul style="margin-top:0em"><li><a href="#hog_image">hog_image</a></li><li><a href="#fine_hog_image">fine_hog_image</a></li><li><a href="#poly_image">poly_image</a></li></ul><BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_keypoint/nearest_neighbor_feature_image_abstract.h.html#nearest_neighbor_feature_image">More Details...</a><div class="include_file">#include &lt;dlib/image_keypoint.h&gt;</div></div></div><a name="normalize_image_gradients"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">normalize_image_gradients</h1><BR><BR>        
            This function takes two gradient images produced by a function like
            <a href="#sobel_edge_detector">sobel_edge_detector</a> and then
            unit normalizes the gradient vectors.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/edge_detector_abstract.h.html#normalize_image_gradients">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="object_detector"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">object_detector</h1><BR><BR>        
                This object is a tool for detecting the positions of objects in an image.  In
                particular, it is a simple container to aggregate an instance of an image
                scanner object (either <a href="#scan_fhog_pyramid">scan_fhog_pyramid</a>,
                <a href="#scan_image_pyramid">scan_image_pyramid</a>, <a href="#scan_image_boxes">scan_image_boxes</a>, or 
                <a href="#scan_image_custom">scan_image_custom</a>), the weight vector
                needed by one of these image scanners, and finally an instance of
                <a href="#test_box_overlap">test_box_overlap</a>.  The test_box_overlap object
                is used to perform non-max suppression on the output of the image scanner
                object.  

                <p>
                   Note that you can use the 
                   <a href="ml.html#structural_object_detection_trainer">structural_object_detection_trainer</a>
                   to learn the parameters of an object_detector.  See the example programs for an introduction.
                </p><p>
                  Also note that dlib contains more powerful <a href="ml.html#loss_mmod_">CNN based object detection
                  tooling</a>, which will usually run slower but produce much
                  more general and accurate detectors.
               </p><BR><BR>C++ Example Programs: <a href="fhog_object_detector_ex.cpp.html">fhog_object_detector_ex.cpp</a>,
               <a href="face_detection_ex.cpp.html">face_detection_ex.cpp</a>,
               <a href="object_detector_ex.cpp.html">object_detector_ex.cpp</a>,
               <a href="object_detector_advanced_ex.cpp.html">object_detector_advanced_ex.cpp</a>,
               <a href="train_object_detector.cpp.html">train_object_detector.cpp</a><BR>Python Example Programs: <a href="face_detector.py.html">face_detector.py</a>,
               <a href="train_object_detector.py.html">train_object_detector.py</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_processing/object_detector_abstract.h.html#object_detector">More Details...</a><div class="include_file">#include &lt;dlib/image_processing.h&gt;</div></div></div><a name="partition_pixels"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">partition_pixels</h1><BR><BR>        
              This function finds a threshold value that would be reasonable to use with
              <a href="#threshold_image">threshold_image</a>.  It does this by finding the threshold that
              partitions the pixels in an image into two groups such that the sum of absolute
              deviations between each pixel and the mean of its group is minimized.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/thresholding_abstract.h.html#partition_pixels">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="partition_pixels"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">partition_pixels</h1><BR><BR>        
              Finds a threshold value that would be reasonable to use with
              <a href="#threshold_image">threshold_image</a>.  It does this by
              finding the threshold that partitions the pixels in an image into
              two groups such that the sum of absolute deviations between each
              pixel and the mean of its group is minimized.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/thresholding_abstract.h.html#partition_pixels">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="pixel_traits"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">pixel_traits</h1><BR><BR>
            As the name implies, this is a traits class for pixel types. It allows you
            to determine what sort of pixel type you are dealing with.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/pixel.h.html">More Details...</a><div class="include_file">#include &lt;dlib/pixel.h&gt;</div></div></div><a name="png_loader"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">png_loader</h1><BR><BR>        
            This object loads a Portable Network Graphics (PNG) image file into 
            an <a href="containers.html#array2d">array2d</a> of <a href="dlib/pixel.h.html">pixels</a>.
            <p>
               Note that you must define DLIB_PNG_SUPPORT if you want to use this object.  You
               must also set your build environment to link to the libpng library.  However,
               if you use CMake and dlib's default CMakeLists.txt file then it will get setup
               automatically.
            </p><BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_loader/png_loader_abstract.h.html#png_loader">More Details...</a><div class="include_file">#include &lt;dlib/image_io.h&gt;</div></div></div><a name="poly_image"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">poly_image</h1><BR><BR>
                This object is a tool for extracting local feature descriptors from an image.
                In particular, it fits polynomials to local pixel patches and
                allows you to query the coefficients of these polynomials.  
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_keypoint/poly_image_abstract.h.html#poly_image">More Details...</a><div class="include_file">#include &lt;dlib/image_keypoint.h&gt;</div></div></div><a name="pyramid_disable"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">pyramid_disable</h1><BR><BR>        
               This object downsamples an image at a ratio of infinity to 1.  That
               means it always outputs an image of size zero.  This is useful because
               it can be supplied to routines which take a pyramid_down function object
               and it will essentially disable pyramid processing.  This way, a pyramid
               oriented function can be turned into a regular routine which processes
               just the original undownsampled image.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/image_pyramid_abstract.h.html#pyramid_disable">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="pyramid_down"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">pyramid_down</h1><BR><BR>        
               This is a simple function object to help create image pyramids.  It 
               downsamples an image by a ratio of N to N-1 where N is supplied by the
               user as a template argument.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/image_pyramid_abstract.h.html#pyramid_down">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="pyramid_up"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">pyramid_up</h1><BR><BR>        
            This routine upsamples an image.  In particular, it takes a  
            <a href="#pyramid_down">pyramid_down</a> object (or an object with a
            compatible interface) as an argument and performs an upsampling
            which is the inverse of the supplied pyramid_down object.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/interpolation_abstract.h.html#pyramid_up">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="randomly_color_image"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">randomly_color_image</h1><BR><BR>
              Randomly generates a mapping from gray level pixel values
              to the RGB pixel space and then uses this mapping to create
              a colored version an image. 
              <p>
                 This function is useful for displaying the results of some image 
                 segmentation.  For example, the output of <a href="#label_connected_blobs">label_connected_blobs</a>,
                 <a href="label_connected_blobs_watershed">label_connected_blobs_watershed</a>, 
                 or <a href="#segment_image">segment_image</a>.
              </p><BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/colormaps_abstract.h.html#randomly_color_image">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="randomly_sample_image_features"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">randomly_sample_image_features</h1><BR><BR>
            Given a feature extractor such as the <a href="#hog_image">hog_image</a>,
            this routine selects a random subsample of local image feature vectors 
            from a set of images.  
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/statistics/image_feature_sampling_abstract.h.html#randomly_sample_image_features">More Details...</a><div class="include_file">#include &lt;dlib/statistics.h&gt;</div></div></div><a name="random_color_transform"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">random_color_transform</h1><BR><BR>
               This object generates a random color balancing and gamma correction
               transform.  It then allows you to apply that specific transform to as many
               <a href="#rgb_pixel">rgb_pixel</a> objects as you like.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/random_color_transform_abstract.h.html#random_color_transform">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="random_cropper"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">random_cropper</h1><BR><BR>        
            This object is a tool for extracting random crops of objects from a set of
            images.  The crops are randomly jittered in scale, translation, and
            rotation but more or less centered on objects specified by <a href="#mmod_rect">mmod_rect</a>
            objects.
         <BR><BR>C++ Example Programs: <a href="random_cropper_ex.cpp.html">random_cropper_ex.cpp</a>,
               <a href="dnn_mmod_ex.cpp.html">dnn_mmod_ex.cpp</a>,
               <a href="dnn_mmod_find_cars_ex.cpp.html">dnn_mmod_find_cars_ex.cpp</a>,
               <a href="dnn_mmod_train_find_cars_ex.cpp.html">dnn_mmod_train_find_cars_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/random_cropper_abstract.h.html#random_cropper">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="remove_incoherent_edge_pixels"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">remove_incoherent_edge_pixels</h1><BR><BR>        
            This routine takes a list of edge pixels and discards the ones that
            have outlying gradient directions. In particular, it finds the
            largest group of pixels in an edge that are all within a user
            specified angle of each other.  Therefore, if you are looking for
            straight lines then this routine is a useful tool since it allows
            you to discard noisy edge pixels with inconsistent angles.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/edge_detector_abstract.h.html#remove_incoherent_edge_pixels">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="remove_unobtainable_rectangles"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">remove_unobtainable_rectangles</h1><BR><BR>        
            Recall that the <a href="#scan_image_pyramid">scan_image_pyramid</a> and 
            <a href="#scan_image_boxes">scan_image_boxes</a> objects can't produce
            all possible rectangles as object detections since they only
            consider a limited subset of all possible object positions.
            Therefore, when training an object detector that uses these tools
            you must make sure the training data does not contain any object
            locations that are unobtainable by the image scanning model.
            The remove_unobtainable_rectangles() routine is a tool to filter out
            these unobtainable rectangles from the training.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_processing/remove_unobtainable_rectangles_abstract.h.html#remove_unobtainable_rectangles">More Details...</a><div class="include_file">#include &lt;dlib/image_processing.h&gt;</div></div></div><a name="render_face_detections"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">render_face_detections</h1><BR><BR>        
            This function takes a set of <a href="#full_object_detection">full_object_detections</a>
            which represent human faces annotated with 68 facial landmarks (according to the iBUG 300-W
            scheme) and converts them into a form suitable for display on an 
            <a href="dlib/gui_widgets/widgets_abstract.h.html#image_window">image_window</a>.

            <p>
               For example, it will take the output of a <a href="#shape_predictor">shape_predictor</a>
               that uses this facial landmarking scheme and will produce visualizations like this:
            </p><img src="face_landmarking_example.png" border="0" height="" width="" alt=""><BR><BR>C++ Example Programs: <a href="face_landmark_detection_ex.cpp.html">face_landmark_detection_ex.cpp</a>,
               <a href="webcam_face_pose_ex.cpp.html">webcam_face_pose_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_processing/render_face_detections_abstract.h.html#render_face_detections">More Details...</a><div class="include_file">#include &lt;dlib/image_processing/render_face_detections.h&gt;</div></div></div><a name="resize_image"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">resize_image</h1><BR><BR>        
            This is a routine capable of resizing or stretching an image.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/interpolation_abstract.h.html#resize_image">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="rgb_alpha_pixel"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">rgb_alpha_pixel</h1><BR><BR>
            This is a simple struct that represents an RGB colored graphical pixel with an 
            alpha channel.  
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/pixel.h.html#rgb_alpha_pixel">More Details...</a><div class="include_file">#include &lt;dlib/pixel.h&gt;</div></div></div><a name="rgb_pixel"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">rgb_pixel</h1><BR><BR>
            This is a simple struct that represents an RGB colored graphical pixel.  
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/pixel.h.html#rgb_pixel">More Details...</a><div class="include_file">#include &lt;dlib/pixel.h&gt;</div></div></div><a name="rotate_image"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">rotate_image</h1><BR><BR>        
            This is a routine for rotating an image. 
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/interpolation_abstract.h.html#rotate_image">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="rotate_image_dataset"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">rotate_image_dataset</h1><BR><BR>        
            This routine takes a set of images and bounding boxes within those
            images and rotates the entire dataset by a user specified angle.  
            This means that all images are rotated and the bounding boxes are adjusted
            so that they still sit on top of the same visual objects in the new rotated images.  
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/interpolation_abstract.h.html#rotate_image_dataset">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="save_bmp"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">save_bmp</h1><BR><BR>        
            This global function saves an image as a MS Windows BMP file. 

            <p>
               This routine can save images containing any type of pixel.  However, it will
               convert all color pixels into <b>rgb_pixel</b> and grayscale pixels into 
               <b>uint8</b> type before saving to disk.  
            </p><BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_saver/image_saver_abstract.h.html#save_bmp">More Details...</a><div class="include_file">#include &lt;dlib/image_io.h&gt;</div></div></div><a name="save_dng"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">save_dng</h1><BR><BR>        
      This global function saves an image as a dlib DNG file (a lossless 
      compressed image format). 
            <p>
               This routine can save images containing any type of pixel.  However, the DNG format
               can natively store only the following pixel types: <b>rgb_pixel</b>, <b>hsi_pixel</b>,
               <b>rgb_alpha_pixel</b>, <b>uint8</b>, <b>uint16</b>, <b>float</b>, and <b>double</b>.  
               All other pixel types will be converted
               into one of these types as appropriate before being saved to disk.
            </p><BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_saver/image_saver_abstract.h.html#save_dng">More Details...</a><div class="include_file">#include &lt;dlib/image_io.h&gt;</div></div></div><a name="save_jpeg"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">save_jpeg</h1><BR><BR>        
         This global function writes an image to disk as a JPEG file. 
            <p>
               Note that you must define DLIB_JPEG_SUPPORT if you want to use this function.  You
               must also set your build environment to link to the libjpeg library.  However,
               if you use CMake and dlib's default CMakeLists.txt file then it will get setup
               automatically.
            </p><p>
               This routine can save images containing any type of pixel.  However, save_jpeg() can
               only natively store the following pixel types: <b>rgb_pixel</b> 
               and <b>uint8</b>.  All other pixel types will be converted into
               one of these types as appropriate before being saved to disk.
            </p><BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_saver/save_jpeg_abstract.h.html#save_jpeg">More Details...</a><div class="include_file">#include &lt;dlib/image_io.h&gt;</div></div></div><a name="save_png"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">save_png</h1><BR><BR>        
      This global function writes an image to disk as a PNG (Portable Network Graphics) file. 
            <p>
               Note that you must define DLIB_PNG_SUPPORT if you want to use this function.  You
               must also set your build environment to link to the libpng library.  However,
               if you use CMake and dlib's default CMakeLists.txt file then it will get setup
               automatically.
            </p><p>
               This routine can save images containing any type of pixel.  However, save_png() can
               only natively store the following pixel types: <b>rgb_pixel</b>, 
               <b>rgb_alpha_pixel</b>, <b>uint8</b>, and <b>uint16</b>.  All other pixel
               types will be converted into one of these types as appropriate before being
               saved to disk.
            </p><BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_saver/save_png_abstract.h.html#save_png">More Details...</a><div class="include_file">#include &lt;dlib/image_io.h&gt;</div></div></div><a name="scan_fhog_pyramid"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">scan_fhog_pyramid</h1><BR><BR>        

                This object is a tool for running a fixed sized sliding window classifier
                over an image pyramid.  In particular,  it slides a linear classifier over
                a HOG pyramid as discussed in the paper:  
                <blockquote>
                    Histograms of Oriented Gradients for Human Detection by Navneet Dalal
                    and Bill Triggs, CVPR 2005
                </blockquote>
                However, we augment the method slightly to use the version of HOG features 
                from: 
                <blockquote>
                    Object Detection with Discriminatively Trained Part Based Models by
                    P. Felzenszwalb, R. Girshick, D. McAllester, D. Ramanan
                    IEEE Transactions on Pattern Analysis and Machine Intelligence, Vol. 32, No. 9, Sep. 2010
                </blockquote>
                Since these HOG features have been shown to give superior performance. 
         <BR><BR>C++ Example Programs: <a href="fhog_object_detector_ex.cpp.html">fhog_object_detector_ex.cpp</a><BR>Python Example Programs: <a href="train_object_detector.py.html">train_object_detector.py</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_processing/scan_fhog_pyramid_abstract.h.html#scan_fhog_pyramid">More Details...</a><div class="include_file">#include &lt;dlib/image_processing.h&gt;</div></div></div><a name="scan_image"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">scan_image</h1><BR><BR>        
            This global function is a tool for sliding a set of rectangles
            over an image space and finding the locations where the sum of pixels in
            the rectangles exceeds a threshold.  It is useful for implementing
            certain kinds of sliding window classifiers.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_processing/scan_image_abstract.h.html#scan_image">More Details...</a><div class="include_file">#include &lt;dlib/image_processing.h&gt;</div></div></div><a name="scan_image_boxes"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">scan_image_boxes</h1><BR><BR>        
            This object is a tool for running a classifier over an image with the goal
            of localizing each object present.  The localization is in the form of the
            bounding box around each object of interest.  

            <p>
            Unlike the <a href="#scan_image_pyramid">scan_image_pyramid</a> object which scans a
            fixed sized window over an image pyramid, the scan_image_boxes tool allows you to
            define your own list of "candidate object locations" which should be evaluated.
            This is simply a list of rectangle objects which might contain objects of
            interest.  The scan_image_boxes object will then evaluate the classifier at each
            of these locations and return the subset of rectangles which appear to have
            objects in them.    
            </p>

            This object can also be understood as a general tool for implementing the spatial
            pyramid models described in the paper:
            <blockquote>
               Beyond Bags of Features: Spatial Pyramid Matching for Recognizing 
               Natural Scene Categories by Svetlana Lazebnik, Cordelia Schmid, 
               and Jean Ponce
            </blockquote><br><br>
            The following feature extractors can be used with the scan_image_boxes object:
            <ul style="margin-top:0em"><li><a href="#hashed_feature_image">hashed_feature_image</a></li><li><a href="#binned_vector_feature_image">binned_vector_feature_image</a></li><li><a href="#nearest_neighbor_feature_image">nearest_neighbor_feature_image</a></li></ul><BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_processing/scan_image_boxes_abstract.h.html#scan_image_boxes">More Details...</a><div class="include_file">#include &lt;dlib/image_processing.h&gt;</div></div></div><a name="scan_image_custom"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">scan_image_custom</h1><BR><BR>        
            This object is a tool for running a classifier over an image with the goal
            of localizing each object present.  The localization is in the form of the
            bounding box around each object of interest.  

            <p>
               Unlike the <a href="#scan_image_pyramid">scan_image_pyramid</a> 
               and <a href="#scan_image_boxes">scan_image_boxes</a> objects, this image
                scanner delegates all the work of constructing the object feature vector to
                a user supplied feature extraction object.  That is, scan_image_custom
                simply asks the supplied feature extractor what boxes in the image we
                should investigate and then asks the feature extractor for the complete
                feature vector for each box.  That is, scan_image_custom does not apply any
                kind of pyramiding or other higher level processing to the features coming
                out of the feature extractor.  That means that when you use
                scan_image_custom it is completely up to you to define the feature vector
                used with each image box.
            </p><BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_processing/scan_image_custom_abstract.h.html#scan_image_custom">More Details...</a><div class="include_file">#include &lt;dlib/image_processing.h&gt;</div></div></div><a name="scan_image_movable_parts"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">scan_image_movable_parts</h1><BR><BR>        
            This global function is a tool for sliding a set of rectangles
            over an image space and finding the locations where the sum of pixels in
            the rectangles exceeds a threshold.  It is useful for implementing
            certain kinds of sliding window classifiers.  The behavior of this
            routine is similar to <a href="#scan_image">scan_image</a> except that
            it can also handle movable parts in addition to rigidly placed parts
            within the sliding window.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_processing/scan_image_abstract.h.html#scan_image_movable_parts">More Details...</a><div class="include_file">#include &lt;dlib/image_processing.h&gt;</div></div></div><a name="scan_image_pyramid"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">scan_image_pyramid</h1><BR><BR>        
                This object is a tool for running a sliding window classifier over
                an image pyramid.  This object can also be understood as a general 
                tool for implementing the spatial pyramid models described in the paper:
                <blockquote>
                    Beyond Bags of Features: Spatial Pyramid Matching for Recognizing 
                    Natural Scene Categories by Svetlana Lazebnik, Cordelia Schmid, 
                    and Jean Ponce
                </blockquote>
                It also includes the ability to represent movable part models.

               <br><br>
               The following feature extractors can be used with the scan_image_pyramid object:
               <ul style="margin-top:0em"><li><a href="#hashed_feature_image">hashed_feature_image</a></li><li><a href="#binned_vector_feature_image">binned_vector_feature_image</a></li><li><a href="#nearest_neighbor_feature_image">nearest_neighbor_feature_image</a></li></ul><BR><BR>C++ Example Programs: <a href="object_detector_ex.cpp.html">object_detector_ex.cpp</a>,
               <a href="object_detector_advanced_ex.cpp.html">object_detector_advanced_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_processing/scan_image_pyramid_abstract.h.html#scan_image_pyramid">More Details...</a><div class="include_file">#include &lt;dlib/image_processing.h&gt;</div></div></div><a name="segment_image"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">segment_image</h1><BR><BR>        
              Attempts to segment an image into regions which have some visual consistency to them.
              In particular, this function implements the algorithm described in the paper:
              <blockquote>
               Efficient Graph-Based Image Segmentation by Felzenszwalb and Huttenlocher.
              </blockquote><BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/segment_image_abstract.h.html#segment_image">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="separable_3x3_filter_block_grayscale"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">separable_3x3_filter_block_grayscale</h1><BR><BR>        
            This routine filters part of an image with a user supplied 3x3 separable filter.
            The output is a grayscale sub-image.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/spatial_filtering_abstract.h.html#separable_3x3_filter_block_grayscale">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="separable_3x3_filter_block_rgb"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">separable_3x3_filter_block_rgb</h1><BR><BR>        
            This routine filters part of an image with a user supplied 3x3 separable filter.
            The output is a RGB sub-image.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/spatial_filtering_abstract.h.html#separable_3x3_filter_block_rgb">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="setup_grid_detection_templates"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">setup_grid_detection_templates</h1><BR><BR>        
            This routine uses <a href="#determine_object_boxes">determine_object_boxes</a> to obtain a set of
              object boxes and then adds them to a <a href="#scan_image_pyramid">scan_image_pyramid</a> object 
              as detection templates.  It also uses <a href="#create_grid_detection_template">create_grid_detection_template</a>
               to create each feature extraction region.  Therefore, the detection templates will extract
              features from a regular grid inside each object box.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_processing/scan_image_pyramid_tools_abstract.h.html#setup_grid_detection_templates">More Details...</a><div class="include_file">#include &lt;dlib/image_processing.h&gt;</div></div></div><a name="setup_grid_detection_templates_verbose"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">setup_grid_detection_templates_verbose</h1><BR><BR>        
            This function is identical to <a href="#setup_grid_detection_templates">setup_grid_detection_templates</a>
            except that it also outputs information regarding the selected detection templates
            to standard out.
         <BR><BR>C++ Example Programs: <a href="object_detector_ex.cpp.html">object_detector_ex.cpp</a>,
               <a href="train_object_detector.cpp.html">train_object_detector.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_processing/scan_image_pyramid_tools_abstract.h.html#setup_grid_detection_templates_verbose">More Details...</a><div class="include_file">#include &lt;dlib/image_processing.h&gt;</div></div></div><a name="setup_hashed_features"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">setup_hashed_features</h1><BR><BR>        
            This is a tool for configuring the <a href="#hashed_feature_image">hashed_feature_image</a>
            or <a href="#binned_vector_feature_image">binned_vector_feature_image</a> object
            with a random <a href="algorithms.html#projection_hash">projection hash</a>. 
         <BR><BR>C++ Example Programs: <a href="object_detector_ex.cpp.html">object_detector_ex.cpp</a>,
               <a href="train_object_detector.cpp.html">train_object_detector.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_processing/setup_hashed_features_abstract.h.html#setup_hashed_features">More Details...</a><div class="include_file">#include &lt;dlib/image_processing.h&gt;</div></div></div><a name="shape_predictor"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">shape_predictor</h1><BR><BR>
                This object is a tool that takes in an image region containing some object
                and outputs a set of point locations that define the pose of the
                object.  The classic example of this is human face pose prediction, where
                you take an image of a human face as input and are expected to identify the
                locations of important facial landmarks such as the corners of the mouth
                and eyes, tip of the nose, and so forth.  For example, here is the output
                of dlib's <a href="face_landmark_detection_ex.cpp.html">68-face-landmark shape_predictor</a> on an image from the HELEN dataset: <br><br><img src="face_landmarking_example.png" border="0" height="" width="" alt=""><br><br>

                To create useful instantiations of this object you need to use the
                <a href="ml.html#shape_predictor_trainer">shape_predictor_trainer</a> object to train a 
                shape_predictor using a set of training images, each annotated with shapes you want to predict.
                To do this, the shape_predictor_trainer uses the state-of-the-art method from the
                paper:
             <blockquote>
                    One Millisecond Face Alignment with an Ensemble of Regression Trees
                    by Vahid Kazemi and Josephine Sullivan, CVPR 2014
             </blockquote><BR><BR>C++ Example Programs: <a href="face_landmark_detection_ex.cpp.html">face_landmark_detection_ex.cpp</a>,
               <a href="train_shape_predictor_ex.cpp.html">train_shape_predictor_ex.cpp</a>,
               <a href="webcam_face_pose_ex.cpp.html">webcam_face_pose_ex.cpp</a><BR>Python Example Programs: <a href="train_shape_predictor.py.html">train_shape_predictor.py</a>,
               <a href="face_landmark_detection.py.html">face_landmark_detection.py</a>,
               <a href="face_alignment.py.html">face_alignment.py</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_processing/shape_predictor_abstract.h.html#shape_predictor">More Details...</a><div class="include_file">#include &lt;dlib/image_processing.h&gt;</div></div></div><a name="skeleton"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">skeleton</h1><BR><BR>
              This function computes the skeletonization of an image.  That is,
              given a binary image, we progressively thin the binary blobs
              until only a single pixel wide skeleton of the original blobs
              remains.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/morphological_operations_abstract.h.html#skeleton">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="sobel_edge_detector"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">sobel_edge_detector</h1><BR><BR>        
            This global function performs spatial filtering on an image using the
            sobel edge detection filters.
         <BR><BR>C++ Example Programs: <a href="image_ex.cpp.html">image_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/edge_detector_abstract.h.html#sobel_edge_detector">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="spatially_filter_image"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">spatially_filter_image</h1><BR><BR>        
            This global function performs spatial filtering on an image with a user
            supplied filter.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/spatial_filtering_abstract.h.html#spatially_filter_image">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="spatially_filter_image_separable"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">spatially_filter_image_separable</h1><BR><BR>        
            This global function performs spatial filtering on an image with a user
            supplied separable filter.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/spatial_filtering_abstract.h.html#spatially_filter_image_separable">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="spatially_filter_image_separable_down"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">spatially_filter_image_separable_down</h1><BR><BR>        
            This global function performs spatial filtering on an image with a user
            supplied separable filter.  Additionally, it produces a downsampled
            output.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/spatial_filtering_abstract.h.html#spatially_filter_image_separable_down">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="sub_image"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">sub_image</h1><BR><BR>        
            This function returns a lightweight sub-image of another image.  In particular,
            the returned sub-image simply holds a pointer to the original image, meaning there
            is no overhead for using or creating the sub-image.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/interpolation_abstract.h.html#sub_image">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="sum_filter"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">sum_filter</h1><BR><BR>        
            This function slides a rectangle over an input image and adds the sum
            of pixel values in each rectangle location to another image.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/spatial_filtering_abstract.h.html#sum_filter">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="sum_filter_assign"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">sum_filter_assign</h1><BR><BR>        
            This function slides a rectangle over an input image and outputs a new 
            image which contains the sum of pixels inside the rectangle at each
            position in the input image.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/spatial_filtering_abstract.h.html#sum_filter_assign">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="suppress_non_maximum_edges"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">suppress_non_maximum_edges</h1><BR><BR>        
            This global function performs non-maximum suppression on a gradient
            image.  
         <BR><BR>C++ Example Programs: <a href="image_ex.cpp.html">image_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/edge_detector_abstract.h.html#suppress_non_maximum_edges">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="surf_point"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">surf_point</h1><BR><BR>
            This is a simple struct used to represent the SURF points returned
            by the <a href="#get_surf_points">get_surf_points</a> function.
         <BR><BR>C++ Example Programs: <a href="surf_ex.cpp.html">surf_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_keypoint/surf_abstract.h.html#surf_point">More Details...</a><div class="include_file">#include &lt;dlib/image_keypoint.h&gt;</div></div></div><a name="test_box_overlap"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">test_box_overlap</h1><BR><BR>        
            This object is a simple function object for determining if two 
            <a href="linear_algebra.html#rectangle">rectangles</a> overlap.  
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_processing/box_overlap_testing_abstract.h.html#test_box_overlap">More Details...</a><div class="include_file">#include &lt;dlib/image_processing.h&gt;</div></div></div><a name="threshold_image"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">threshold_image</h1><BR><BR>        
            This global function performs a simple binary thresholding on an image with a user
            supplied threshold.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/thresholding_abstract.h.html#threshold_image">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="tile_images"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">tile_images</h1><BR><BR>        
              This function takes an array of images and tiles them into a single large
              square image and returns this new big tiled image.  Therefore, it is a useful
              method to visualize many small images at once.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/draw_abstract.h.html#tile_images">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="toMat"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">toMat</h1><BR><BR>
            This routine converts a dlib style image into an instance of OpenCV's cv::Mat object.
            This is done by setting up the Mat object to point to the same memory as the dlib image.
               <p>
                  Note that you can do the reverse conversion, from OpenCV to dlib,
                  using the <a href="#cv_image">cv_image</a> object.  
               </p><BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/opencv/to_open_cv_abstract.h.html#toMat">More Details...</a><div class="include_file">#include &lt;dlib/opencv.h&gt;</div></div></div><a name="transform_image"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">transform_image</h1><BR><BR>        
            This routine is a tool for transforming images using some kind of point mapping
            function (e.g. <a href="linear_algebra.html#point_transform_affine">point_transform_affine</a>)
            and pixel interpolation tool (e.g. <a href="#interpolate_quadratic">interpolate_quadratic</a>).
            An example application of this routine is for image rotation.  Indeed, it is how 
            <a href="#rotate_image">rotate_image</a> is implemented.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/interpolation_abstract.h.html#transform_image">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="upsample_image_dataset"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">upsample_image_dataset</h1><BR><BR>        
            This routine takes a set of images and bounding boxes within those images and
            upsamples the entire dataset.  This means that all images are upsampled and the
            bounding boxes are adjusted so that they still sit on top of the same visual
            objects in the new images.  
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/interpolation_abstract.h.html#upsample_image_dataset">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div><a name="zero_border_pixels"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">zero_border_pixels</h1><BR><BR>        
            This global function zeros the pixels on the border of an image.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_transforms/assign_image_abstract.h.html#zero_border_pixels">More Details...</a><div class="include_file">#include &lt;dlib/image_transforms.h&gt;</div></div></div></div></body></html>
